<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>waveguicsx.waveguide &mdash; waveguicsx 1.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html">
            <img src="../../_static/logo_doc.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme_link.html">Presentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#introduction">0. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#basic-examples">1. Basic examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#prerequisites">2. Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#installation">3. Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#documentation">4. Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#tutorials">5. Tutorials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#scattering-by-local-inhomogeneities">6. Scattering by local inhomogeneities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#authors-and-contributors">7. Authors and contributors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#how-to-cite">8. How to cite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#license">9. License</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../documentation.html">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../waveguicsx.html">waveguicsx.waveguide</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#three-dimensional-elastic-bar-of-square-cross-section">0. Three-dimensional elastic bar of square cross-section</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#three-dimensional-elastic-bar-of-square-cross-section-with-parallelization">1. Three-dimensional elastic bar of square cross-section with parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#three-dimensional-elastic-bar-of-square-cross-section-buried-into-a-pml-external-medium">2. Three-dimensional elastic bar of square cross-section buried into a PML external medium</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#three-dimensional-elastic-bar-of-square-cross-section-buried-into-a-pml-external-medium-using-gmsh">3. Three-dimensional elastic bar of square cross-section buried into a PML external medium using gmsh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#excitation-of-a-three-dimensional-elastic-bar-of-circular-cross-section">4. Excitation of a three-dimensional elastic bar of circular cross-section</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#excitation-of-a-three-dimensional-elastic-bar-of-circular-cross-section-with-parallelization">5. Excitation of a three-dimensional elastic bar of circular cross-section with parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#time-response-of-a-two-dimensional-plate-excited-near-its-first-zgv-resonance">6. Time response of a two-dimensional plate excited near its first ZGV resonance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#dispersion-curves-of-a-rail">7. Dispersion curves of a rail</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#reflection-of-lamb-modes-by-the-free-edge-of-a-plate">8. Reflection of Lamb modes by the free edge of a plate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#reflection-and-transmission-of-pochhammer-chree-modes-inside-a-cylinder">9. Reflection and transmission of Pochhammer-Chree modes inside a cylinder</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">waveguicsx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">waveguicsx.waveguide</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for waveguicsx.waveguide</h1><div class="highlight"><pre>
<span></span><span class="c1">#####################################################################</span>
<span class="c1"># waveguicsx, a python library for solving complex waveguide problems</span>
<span class="c1"># </span>
<span class="c1"># Copyright (C) 2023-2024  Fabien Treyssede</span>
<span class="c1"># </span>
<span class="c1"># This file is part of waveguicsx.</span>
<span class="c1"># </span>
<span class="c1"># waveguicsx is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</span>
<span class="c1"># </span>
<span class="c1"># waveguicsx is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</span>
<span class="c1"># </span>
<span class="c1"># You should have received a copy of the GNU General Public License along with waveguicsx. If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="c1"># </span>
<span class="c1"># Contact: fabien.treyssede@univ-eiffel.fr</span>
<span class="c1">#####################################################################</span>


<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">petsc4py</span> <span class="kn">import</span> <span class="n">PETSc</span>
<span class="kn">from</span> <span class="nn">slepc4py</span> <span class="kn">import</span> <span class="n">SLEPc</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">time</span>


<div class="viewcode-block" id="Waveguide"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide">[docs]</a><span class="k">class</span> <span class="nc">Waveguide</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for solving complex waveguide problems based on SLEPc eigensolver.</span>
<span class="sd">    </span>
<span class="sd">    The full documentation is entirely defined in the `waveguide.py&#39; module.</span>

<span class="sd">    The following matrix problem is considered: (K0-omega**2*M + 1j*k*(K1-K1^T) + k**2*K2)*U=F.</span>
<span class="sd">    This kind of problem typically stems from the so-called SAFE (Semi-Analytical Finite Element) method.</span>
<span class="sd">    </span>
<span class="sd">    The class enables to deal with complex waveguides, two-dimensional (e.g. plates) or three-dimensional (arbitrarily</span>
<span class="sd">    shaped cross-section), inhomogeneous in the transverse directions, anisotropic. Complex-valued problems can be handled</span>
<span class="sd">    including the effects of non-propagating modes (evanescent, inhomogeneous), viscoelastic loss (complex material</span>
<span class="sd">    properties) or perfectly matched layers (PML) to simulate buried waveguides.</span>
<span class="sd">    </span>
<span class="sd">    The free response (F=0) is an eigenvalue problem, solved iteratively by varying the parameter</span>
<span class="sd">    which can be the angular frequency omega or the wavenumber k. In the former case, the eigenvalue is k,</span>
<span class="sd">    while in the latter case, the eigenvalue is omega^2. The loops over the parameter (angular frequency or wavenumber)</span>
<span class="sd">    can be parallelized, as shown in some tutorials (using mpi4py).</span>
<span class="sd">    </span>
<span class="sd">    Various modal properties (energy velocity, group velocity, excitability...) can be post-processed as a function of the</span>
<span class="sd">    frequency and plotted as dispersion curves.</span>
<span class="sd">    </span>
<span class="sd">    The forced reponse (F is not 0) is solved in the frequency domain by expanding the solution as a sum of</span>
<span class="sd">    eigenmodes using biorthogonality relationship, leading to very fast computations of excited wavefields.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Example::</span>

<span class="sd">        # In this example, the matrices M, K0, K1, K2 and the excitation vector F are supposed to be dimensional for simplicity</span>
<span class="sd">        # Yet, in practice, the problem would better be normalized to avoid ill-conditioning (see tutorials)</span>

<span class="sd">        from waveguicsx.waveguide import Waveguide</span>

<span class="sd">        # Definition of the excitation signal (here, a toneburst)</span>
<span class="sd">        excitation = Signal()</span>
<span class="sd">        excitation.toneburst(fs=400e3, T=2e-3, fc=100e3, n=8) #central frequency 100 kHz, 8 cycles, duration 2 ms, sampling frequency 400 kHz</span>
<span class="sd">        excitation.plot() #plot time signal</span>
<span class="sd">        excitation.plot_spectrum() #plot spectrum</span>
<span class="sd">        omega = 2*np.pi*excitation.frequency #angular frequency range</span>

<span class="sd">        # Initialization of waveguide</span>
<span class="sd">        wg = Waveguide(MPI.COMM_WORLD, M, K0, K1, K2)</span>
<span class="sd">        wg.set_parameters(omega=omega) #set the parameter range (here, angular frequency)</span>

<span class="sd">        # Free response (dispersion curves)</span>
<span class="sd">        wg.solve(nev=20, target=0) #solution of eigenvalue problem (iteration over the parameter omega), 20 eigenvalues requested at each frequency</span>
<span class="sd">        wg.compute_energy_velocity() #post-process energy velocity</span>
<span class="sd">        wg.plot() #plot k vs. omega</span>
<span class="sd">        wg.plot_energy_velocity() #plot ve vs. omega</span>

<span class="sd">        # Computation of modal coefficients due to an excitation vector F</span>
<span class="sd">        wg.compute_response_coefficient(F=F) #F should be a PETSc vector</span>
<span class="sd">        wg.plot_coefficient() #plot modal coefficients vs. omega</span>

<span class="sd">        # Forced response at degree of freedom dof and axial coordinates z (dof should be an integer)</span>
<span class="sd">        frequency, response = wg.compute_response(dof=dof, z=[0.5, 1., 1.5, 2.], spectrum=excitation.spectrum, plot=False) #response in the frequency domain</span>
<span class="sd">        response = Signal(frequency=frequency, spectrum=response) #define response as a Signal object</span>
<span class="sd">        response.plot_spectrum() #plot frequency response</span>
<span class="sd">        response.ifft() #response in the time domain</span>
<span class="sd">        response.plot() #plot time response</span>
<span class="sd">        plt.show()</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    comm : mpi4py.MPI.Intracomm</span>
<span class="sd">        MPI communicator (parallel processing)</span>
<span class="sd">    M, K0, K1, K2 : petsc4py.PETSc.Mat</span>
<span class="sd">        SAFE matrices</span>
<span class="sd">    F : petsc4py.PETSc.Vec</span>
<span class="sd">        SAFE excitation vector</span>
<span class="sd">    problem_type : str</span>
<span class="sd">        problem_type is &quot;omega&quot; if the varying parameter is omega, &quot;wavenumber&quot; if this is k</span>
<span class="sd">    two_sided : bool</span>
<span class="sd">        if True, left eigenvectors will be also computed (otherwise, only right eigenvectors are computed)</span>
<span class="sd">    target: complex number or user-defined function of the parameter</span>
<span class="sd">        target around which eigenpairs are looked for (see method solve)</span>
<span class="sd">    omega or wavenumber : numpy.ndarray</span>
<span class="sd">        the parameter range specified by the user (see method set_parameters)</span>
<span class="sd">    evp : PEP or EPS instance (SLEPc object)</span>
<span class="sd">        eigensolver parameters</span>
<span class="sd">    eigenvalues : list of numpy arrays</span>
<span class="sd">        list of wavenumbers or angular frequencies,</span>
<span class="sd">        access to components with eigenvalues[ip][imode] (ip: parameter index, imode: mode index)</span>
<span class="sd">    eigenvectors : list of PETSc matrices</span>
<span class="sd">        list of mode shapes,</span>
<span class="sd">        access to components with eigenvectors[ik][idof,imode] (ik: parameter index, imode: mode index, idof: dof index)</span>
<span class="sd">        or eigenvectors[ik].getColumnVector(imode)</span>
<span class="sd">    eigenforces : list of PETSc matrices</span>
<span class="sd">        list of eigenforces (acces to components: see eigenvectors)</span>
<span class="sd">    opposite_going : list of numpy arrays</span>
<span class="sd">        list of opposite-going mode (acces to components: see eigenvectors)</span>
<span class="sd">    energy_velocity : list of numpy arrays</span>
<span class="sd">        list of energy velocity (access to component: see eigenvalues)</span>
<span class="sd">    group_velocity : list of numpy arrays</span>
<span class="sd">        list of group velocity (access to component: see eigenvalues)</span>
<span class="sd">    traveling_direction : list of numpy arrays</span>
<span class="sd">        list of traveling_direction (access to component: see eigenvalues)</span>
<span class="sd">    pml_ratio : list of numpy arrays</span>
<span class="sd">        list of pml ratio, used for filtering out PML modes (access to component: see eigenvalues)</span>
<span class="sd">    coefficient : list of numpy arrays</span>
<span class="sd">        list of response coefficient to excitation vector F (access to component: see eigenvalues)</span>
<span class="sd">    excitability : list of numpy arrays</span>
<span class="sd">        list of excitability to excitation vector F (access to component: see eigenvalues)</span>
<span class="sd">    complex_power : list of numpy arrays</span>
<span class="sd">        list of complex power flow of individual modes (access to component: see eigenvalues)</span>
<span class="sd">    plot_scaler : dictionnary</span>
<span class="sd">        dictionnary containing the scaling factors of various modal properties, useful to plot results in a dimensional form</span>
<span class="sd">    </span>
<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __init__(comm:&#39;_MPI.Comm&#39;, M:PETSc.Mat, K0:PETSc.Mat, K1:PETSc.Mat, K2:PETSc.Mat):</span>
<span class="sd">        Constructor, initialization of waveguide</span>
<span class="sd">    set_parameters(omega=None, wavenumber=None, two_sided=False):</span>
<span class="sd">        Set problem type (problem_type), the parameter range (omega or wavenumber) as well as default parameters of SLEPc eigensolver (evp);</span>
<span class="sd">        set two_sided to True to compute left eigenvectors also (left eigenvectors are the opposite-going modes)</span>
<span class="sd">    solve(nev=1, target=0):</span>
<span class="sd">        Solve the eigenvalue problem repeatedly for the parameter range, solutions are stored as attributes (names: eigenvalues,</span>
<span class="sd">        eigenvectors)</span>
<span class="sd">    compute_eigenforce():</span>
<span class="sd">        Compute the eigenforces for the whole parameter range and store them as an attribute (name: eigenforces)</span>
<span class="sd">    compute_poynting_normalization():</span>
<span class="sd">        Normalization of eigenvectors and eigenforces, so that U&#39;=U/sqrt(|P|), where P is the normal component of complex Poynting vector</span>
<span class="sd">    compute_opposite_going(plot=False):</span>
<span class="sd">        Compute opposite-going mode pairs based on on wavenumber and biorthogonality for the whole parameter range and store</span>
<span class="sd">        them as attributes (name: opposite_going), set plot to True to visualize the biorthogonality values of detected pairs        </span>
<span class="sd">    compute_energy_velocity():</span>
<span class="sd">        Compute the energy velocities for the whole parameter range and store them as an attribute (name: energy_velocity)</span>
<span class="sd">    compute_group_velocity():</span>
<span class="sd">        Compute the group velocities for the whole parameter range and store them as an attribute (name: energy_velocity)</span>
<span class="sd">    compute_traveling_direction():</span>
<span class="sd">        Compute the traveling directions for the whole parameter range and store them as an attribute (name: traveling_direction)</span>
<span class="sd">    compute_pml_ratio():</span>
<span class="sd">        Compute the pml ratios for the whole parameter range and store them as an attribute (name: pml_ratio)</span>
<span class="sd">    compute_response_coefficient(F, spectrum=None, wavenumber_function=None, dof=None):</span>
<span class="sd">        Compute the response coefficients due to excitation vector F for the whole parameter range and store them as</span>
<span class="sd">        an attribute (name: coefficient)</span>
<span class="sd">    compute_complex_power(self):</span>
<span class="sd">        Compute the individual complex power flow of modes given by P=-1j*omega/2*U^H*F</span>
<span class="sd">    compute_response(dof, z, spectrum=None, wavenumber_function=None, plot=False):</span>
<span class="sd">        Compute the response at the degree of freedom dof and the axial coordinate z for the whole frequency range</span>
<span class="sd">    track_mode(omega_index, mode_index, threshold=0.9, plot=False):</span>
<span class="sd">        Track a mode over the whole frequency range thanks to eigenvector similarity. The mode is specified by its</span>
<span class="sd">        index, mode_index, at a given angular frequency index, omega_index.</span>
<span class="sd">    plot(direction=None, pml_threshold=None, ax=None, color=&quot;k&quot;,  marker=&quot;o&quot;, markersize=2, linestyle=&quot;&quot;, **kwargs):</span>
<span class="sd">        Plot dispersion curves Re(omega) vs. Re(wavenumber) using matplotlib</span>
<span class="sd">    plot_phase_velocity(direction=None, pml_threshold=None, ax=None, color=&quot;k&quot;, marker=&quot;o&quot;, markersize=2, linestyle=&quot;&quot;, **kwargs):</span>
<span class="sd">        Plot phase velocity dispersion curves, vp=Re(omega)/Re(wavenumber) vs. Re(omega)</span>
<span class="sd">    plot_attenuation(direction=None, pml_threshold=None, ax=None, color=&quot;k&quot;, marker=&quot;o&quot;, markersize=2, linestyle=&quot;&quot;, **kwargs):</span>
<span class="sd">        Plot attenuation dispersion curves, Im(wavenumber) vs. Re(omega) if omega is the parameter,</span>
<span class="sd">        or Im(omega) vs. Re(omega) if wavenumber is the parameter</span>
<span class="sd">    plot_energy_velocity(direction=None, pml_threshold=None, ax=None, color=&quot;k&quot;, marker=&quot;o&quot;, markersize=2, linestyle=&quot;&quot;, **kwargs):</span>
<span class="sd">        Plot energy velocity dispersion curves, ve vs. Re(omega)</span>
<span class="sd">    plot_group_velocity(direction=None, pml_threshold=None, ax=None, color=&quot;k&quot;, marker=&quot;o&quot;, markersize=2, linestyle=&quot;&quot;, **kwargs):</span>
<span class="sd">        Plot group velocity dispersion curves, vg vs. Re(omega)</span>
<span class="sd">    plot_coefficient(direction=None, pml_threshold=None, ax=None, color=&quot;k&quot;, marker=&quot;o&quot;, markersize=2, linestyle=&quot;&quot;, **kwargs):</span>
<span class="sd">        Plot response coefficients as a function of frequency, |q| vs. Re(omega)</span>
<span class="sd">    plot_excitability(direction=None, pml_threshold=None, ax=None, color=&quot;k&quot;, marker=&quot;o&quot;, markersize=2, linestyle=&quot;&quot;, **kwargs):</span>
<span class="sd">        Plot excitability as a function of frequency, |e| vs. Re(omega)</span>
<span class="sd">    plot_spectrum(index=0, ax=None, color=&quot;k&quot;, marker=&quot;o&quot;, markersize=2, linestyle=&quot;&quot;, **kwargs):</span>
<span class="sd">        Plot the spectrum, Im(eigenvalues) vs. Re(eigenvalues), for the parameter index specified by the user</span>
<span class="sd">    set_plot_scaler(length=1, time=1, mass=1, dim=3):</span>
<span class="sd">        Define the characteristic length, time, mass, as well as dim, and calculate the scaling factors of modal</span>
<span class="sd">        properties, which are stored in the attribute name plot_scaler (useful to visualize plots in a dimensional form)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comm</span><span class="p">:</span><span class="s1">&#39;_MPI.Comm&#39;</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span><span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">,</span> <span class="n">K0</span><span class="p">:</span><span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">,</span> <span class="n">K1</span><span class="p">:</span><span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">,</span> <span class="n">K2</span><span class="p">:</span><span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        comm : mpi4py.MPI.Intracomm</span>
<span class="sd">            MPI communicator (parallel processing)</span>
<span class="sd">        M, K0, K1, K2 : petsc4py.PETSc.Mat</span>
<span class="sd">            SAFE matrices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="n">comm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K0</span> <span class="o">=</span> <span class="n">K0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K1</span> <span class="o">=</span> <span class="n">K1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K2</span> <span class="o">=</span> <span class="n">K2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Set the default values for the internal attributes used in this class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;wavenumber&quot;</span><span class="p">,</span> <span class="s2">&quot;omega&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">complex</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavenumber</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">complex</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">two_sided</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">complex</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">PEP</span><span class="p">,</span> <span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">complex</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PETSc</span><span class="o">.</span><span class="n">MAT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PETSc</span><span class="o">.</span><span class="n">MAT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opposite_going</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energy_velocity</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_velocity</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pml_ratio</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">complex</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excitability</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">complex</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complex_power</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">complex</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">,</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">,</span><span class="s1">&#39;energy_velocity&#39;</span><span class="p">,</span><span class="s1">&#39;group_velocity&#39;</span><span class="p">,</span><span class="s1">&#39;pml_ratio&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;eigenvalues&#39;</span><span class="p">,</span><span class="s1">&#39;excitability&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;eigenvectors&#39;</span><span class="p">,</span><span class="s1">&#39;eigenforces&#39;</span><span class="p">,</span><span class="s1">&#39;coefficient&#39;</span><span class="p">,</span><span class="s1">&#39;complex_power&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;frequency&#39;</span><span class="p">,</span><span class="s1">&#39;attenuation&#39;</span><span class="p">,</span><span class="s1">&#39;phase_velocity&#39;</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_poynting_normalization</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_biorthogonality_factor</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Print the number of degrees of freedom</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Total number of degrees of freedom: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Waveguide.set_parameters"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.set_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">set_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">omega</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">complex</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">wavenumber</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">complex</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">two_sided</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the parameter range (omega or wavenumber) as well as default parameters of the SLEPc eigensolver (evp).</span>
<span class="sd">        The user must specify the parameter omega or wavenumber, but not both.</span>
<span class="sd">        This method generates the attributes omega (or wavenumber) and evp.</span>
<span class="sd">        After calling this method, various SLEPc parameters can be set by changing the attribute evp manually.</span>
<span class="sd">        Set two_sided=True for solving left eigenvectors also.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        omega or wavenumber : numpy.ndarray</span>
<span class="sd">            the parameter range specified by the user</span>
<span class="sd">        two_sided : bool</span>
<span class="sd">            False if left eigenvectiors are not needed, True if they must be solved also</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigenvalue problem already solved (re-initialize the Waveguide object to solve a new eigenproblem)&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">wavenumber</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">omega</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Please specify omega or wavenumber (and not both)&#39;</span><span class="p">)</span>
        
        <span class="c1"># The parameter is the frequency omega, the eigenvalue is the wavenumber k</span>
        <span class="k">if</span> <span class="n">wavenumber</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">=</span> <span class="s2">&quot;omega&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">two_sided</span><span class="p">:</span> <span class="c1">#left eigenvectors not required</span>
                <span class="c1"># Setup the SLEPc solver for the quadratic eigenvalue problem</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evp</span> <span class="o">=</span> <span class="n">SLEPc</span><span class="o">.</span><span class="n">PEP</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setProblemType</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">PEP</span><span class="o">.</span><span class="n">ProblemType</span><span class="o">.</span><span class="n">GENERAL</span><span class="p">)</span> <span class="c1">#note: for the undamped case, HERMITIAN is possible with QARNOLDI and TOAR but surprisingly not faster</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">PEP</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">LINEAR</span><span class="p">)</span> <span class="c1">#note: the computational speed of LINEAR, QARNOLDI and TOAR seems to be almost identical</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setWhichEigenpairs</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">PEP</span><span class="o">.</span><span class="n">Which</span><span class="o">.</span><span class="n">TARGET_IMAGINARY</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#left eigenvectors required by user</span>
                <span class="c1"># Setup the SLEPc solver for the quadratic eigenvalue problem linearized externally! (SLEPc.EPS used, setTwoSided is not available in SLEPc.PEP)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evp</span> <span class="o">=</span> <span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setProblemType</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">ProblemType</span><span class="o">.</span><span class="n">GNHEP</span><span class="p">)</span> <span class="c1">#note: GHEP (generalized Hermitian) is surprinsingly a little bit slower...</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">KRYLOVSCHUR</span><span class="p">)</span> <span class="c1">#note: ARNOLDI also works although slightly slower</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setWhichEigenpairs</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">Which</span><span class="o">.</span><span class="n">TARGET_IMAGINARY</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setTwoSided</span><span class="p">(</span><span class="n">two_sided</span><span class="p">)</span>

        <span class="c1"># The parameter is the frequency omega, the eigenvalue is the wavenumber k</span>
        <span class="k">elif</span> <span class="n">omega</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">two_sided</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;two_sided has been set to True: not implemented in case wavenumber is the parameter&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">=</span> <span class="s2">&quot;wavenumber&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavenumber</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wavenumber</span><span class="p">)</span>
            <span class="c1"># Setup the SLEPc solver for the generalized eigenvalue problem</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evp</span> <span class="o">=</span> <span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setProblemType</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">ProblemType</span><span class="o">.</span><span class="n">GNHEP</span><span class="p">)</span> <span class="c1">#note: GHEP (generalized Hermitian) is surprinsingly a little bit slower...</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">KRYLOVSCHUR</span><span class="p">)</span> <span class="c1">#note: ARNOLDI also works although slightly slower</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setWhichEigenpairs</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="o">.</span><span class="n">Which</span><span class="o">.</span><span class="n">TARGET_MAGNITUDE</span><span class="p">)</span>
            <span class="c1">#self.evp.setTwoSided(two_sided) #two_sided not implemented: left for future work if necessary</span>
        
        <span class="c1"># Common setup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">two_sided</span> <span class="o">=</span> <span class="n">two_sided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setTolerances</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">max_it</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
        <span class="n">ST</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">getST</span><span class="p">()</span>
        <span class="n">ST</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="n">SLEPc</span><span class="o">.</span><span class="n">ST</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">SINVERT</span><span class="p">)</span>
        <span class="c1">#ST.setShift(1e-6) #do not set shift here: it will be set automatically to target later (see solve method)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setST</span><span class="p">(</span><span class="n">ST</span><span class="p">)</span>
        <span class="c1">#self.evp.st.ksp.setType(&#39;preonly&#39;) #&#39;preonly&#39; is the default, other choice could be &#39;gmres&#39;, &#39;bcgs&#39;...</span>
        <span class="c1">#self.evp.st.ksp.pc.setType(&#39;lu&#39;) #&#39;lu&#39; is the default, other choice could be &#39;bjacobi&#39;...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setFromOptions</span><span class="p">()</span></div>

<div class="viewcode-block" id="Waveguide.solve"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nev</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the dispersion problem, i.e. the eigenvalue problem repeatedly for the parameter range (omega or wavenumber).</span>
<span class="sd">        The solutions are stored in the attributes eigenvalues and eigenvectors.</span>
<span class="sd">        If two_sided is True, left eigensolutions are also solved.</span>
<span class="sd">        </span>
<span class="sd">        Note: left eigensolutions correspond to opposite-going modes and are hence added to the right eigensolutions</span>
<span class="sd">        (i.e. in eigenvalues and eigenvectors) after removing any possible duplicates.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nev : int</span>
<span class="sd">            number of eigenpairs requested</span>
<span class="sd">        target : complex number or user-defined function of the parameter, optional (default: 0)</span>
<span class="sd">            target around which eigenpairs are looked for</span>
<span class="sd">            a small shift might sometimes prevent errors (e.g. zero pivot with dirichlet bc)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigenvalue problem already solved (re-initialize the Waveguide object to solve a new eigenproblem)&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">two_sided</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Setting two_sided to True is useless here, please set two_sided to False (target has been set to zero, so that both positive and negative-going modes will be computed) &#39;</span><span class="p">)</span>
        
        <span class="c1"># Eigensolver setup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setDimensions</span><span class="p">(</span><span class="n">nev</span><span class="o">=</span><span class="n">nev</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span> <span class="c1">#redefine target as a constant function if target is given as a number</span>
            <span class="n">target_constant</span> <span class="o">=</span> <span class="n">target</span>
            <span class="n">target</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">parameter_value</span><span class="p">:</span> <span class="n">target_constant</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;omega&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">two_sided</span><span class="p">:</span> <span class="c1">#build Zero and Id matrices</span>
            <span class="n">Zero</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">createAIJ</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">getSize</span><span class="p">(),</span> <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
            <span class="n">Zero</span><span class="o">.</span><span class="n">setUp</span><span class="p">()</span>
            <span class="n">Zero</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>
            <span class="n">Id</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">createAIJ</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">getSize</span><span class="p">(),</span> <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
            <span class="n">Id</span><span class="o">.</span><span class="n">setUp</span><span class="p">()</span>
            <span class="n">Id</span><span class="o">.</span><span class="n">setDiagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">createVecRight</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Id</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>
        
        <span class="c1"># Loop over the parameter</span>
        <span class="n">K1T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="c1">#K1^T is stored before loop (faster computations)</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;omega&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="s2">&quot;wavenumber&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavenumber</span><span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Waveguide parameter: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span><span class="si">}</span><span class="s1"> iterations)&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">parameter_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setTarget</span><span class="p">(</span><span class="n">target</span><span class="p">(</span><span class="n">parameter_value</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s2">&quot;wavenumber&quot;</span><span class="p">:</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setOperators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K0</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">parameter_value</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K1</span><span class="o">-</span><span class="n">K1T</span><span class="p">)</span> <span class="o">+</span> <span class="n">parameter_value</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;omega&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">two_sided</span><span class="p">:</span> <span class="c1">#left eigenvectors not required -&gt; PEP class is used</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setOperators</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">K0</span><span class="o">-</span><span class="n">parameter_value</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K1</span><span class="o">-</span><span class="n">K1T</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#left eigenvectors are required -&gt; linearize the quadratic evp and use EPS class (PEP class is not possible)</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">#self.K2.norm(norm_type=PETSc.NormType.FROBENIUS) #NORM_1, FROBENIUS (same as NORM_2 for vectors), INFINITY</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">setOperators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_block_matrix</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K0</span><span class="o">-</span><span class="n">parameter_value</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K1</span><span class="o">-</span><span class="n">K1T</span><span class="p">),</span> <span class="n">Zero</span><span class="p">,</span> <span class="n">coeff</span><span class="o">*</span><span class="n">Id</span><span class="p">),</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_build_block_matrix</span><span class="p">(</span><span class="n">Zero</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="p">,</span> <span class="n">coeff</span><span class="o">*</span><span class="n">Id</span><span class="p">,</span> <span class="n">Zero</span><span class="p">))</span>
                    <span class="c1">#Note: the operators below enable to get the eigenforces but increase computation time -&gt; discarded...</span>
                    <span class="c1">#self.evp.setOperators(self._build_block_matrix(self.K0-parameter_value**2*self.M, Zero, -K1T, Id),</span>
                    <span class="c1">#                      self._build_block_matrix(-1j*self.K1, 1j*Id, 1j*self.K2, Zero))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
            <span class="c1">#self.evp.errorView()</span>
            <span class="c1">#self.evp.valuesView()</span>
            <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_eigenpairs</span><span class="p">(</span><span class="n">two_sided</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">two_sided</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eigenvectors</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">, elapsed time :</span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s&#39;</span><span class="p">)</span>
            <span class="c1">#self.evp.setInitialSpace(self.eigenvectors[-1]) #self.evp.setLeftInitialSpace(....) #try to use current modal basis to compute next, but may be only the first eigenvector...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_poynting_normalization</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#print(&#39;\n---- SLEPc setup (based on last iteration) ----\n&#39;)</span>
        <span class="c1">#self.evp.view()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        
        <span class="c1"># Memory saving</span>
        <span class="n">K1T</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Waveguide.compute_eigenforces"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.compute_eigenforces">[docs]</a>    <span class="k">def</span> <span class="nf">compute_eigenforces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Post-process the eigenforces F=(K1^T+1j*k*K2)*U for every mode in the whole parameter range&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigenforces already computed&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">K1T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="c1">#K1^T is stored before loop (faster computations)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">):</span>
            <span class="n">wavenumber</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concatenate</span><span class="p">(</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="c1">#repeat parameter as many times as the number of eigenvalues</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">K1T</span><span class="o">*</span><span class="n">eigenvectors</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="o">*</span><span class="n">eigenvectors</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">(</span><span class="n">wavenumber</span><span class="p">))</span>
        <span class="n">K1T</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computation of eigenforces, elapsed time : </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Waveguide.compute_poynting_normalization"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.compute_poynting_normalization">[docs]</a>    <span class="k">def</span> <span class="nf">compute_poynting_normalization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-process the normalization of eigenvectors and eigenforces, so that U&#39;=U/sqrt(|P|),</span>
<span class="sd">        where P is the normal component of complex Poynting vector (P=-1j*omega/2*U^H*F).</span>
<span class="sd">        After normalization, every mode is such that |P|=1 and the attribute _poynting_normalization is set to True.</span>
<span class="sd">        Normalization is not mandatory but, when applied, has to be done before any response coefficient computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#response already computed</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Normalization has to be applied before response coefficient computation&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poynting_normalization</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Poynting normalization of eigenvectors already computed&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#compute the eigenforces if not yet computed      </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_eigenforces</span><span class="p">()</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">)):</span>
            <span class="c1">#repeat parameter as many times as the number of eigenvalues</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concatenate</span><span class="p">(</span><span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="c1">#Normalization</span>
            <span class="n">normalization</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
                <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
                <span class="n">normalization</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normalization</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">))))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">(</span><span class="n">normalization</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">(</span><span class="n">normalization</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_poynting_normalization</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computation of Poynting normalization, elapsed time : </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s&#39;</span><span class="p">)</span></div>
        <span class="c1">#print(np.array([-1j*omega[mode]/2*np.vdot(self.eigenvectors[i][:,mode], self.eigenforces[i][:,mode]) for mode in range(self.eigenvalues[i].size)])) #check for last iteration</span>

<div class="viewcode-block" id="Waveguide.compute_energy_velocity"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.compute_energy_velocity">[docs]</a>    <span class="k">def</span> <span class="nf">compute_energy_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-process the energy velocity ve=Re(P)/Re(E) for every mode in the whole parameter range, where P is the</span>
<span class="sd">        normal component of complex Poynting vector and E is the total energy (cross-section time-averaged).</span>
<span class="sd">        Warning in case of PML: the integration is currently applied over the whole cross-section (including PML),</span>
<span class="sd">        the so-defined energy velocity is questionable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_velocity</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Energy velocity already computed&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="c1"># Compute the eigenforces if not yet computed</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_eigenforces</span><span class="p">()</span>
        
        <span class="c1"># Energy velocity, integration on the whole domain</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">K1T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="c1">#K1^T is stored before loop (faster computations)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">):</span>
            <span class="c1">#repeat parameter as many times as the number of eigenvalues</span>
            <span class="n">wavenumber</span><span class="p">,</span> <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concatenate</span><span class="p">(</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">,</span> <span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="c1">#time averaged kinetic energy</span>
            <span class="n">E</span> <span class="o">=</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dot_eigenvectors</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">*</span><span class="n">eigenvectors</span><span class="p">))</span> 
            <span class="c1">#add time averaged potential energy</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">+</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dot_eigenvectors</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K0</span><span class="o">*</span><span class="n">eigenvectors</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">K1</span><span class="o">*</span><span class="n">eigenvectors</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">(</span><span class="n">wavenumber</span><span class="p">)</span>
                                                        <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">K1T</span><span class="o">*</span><span class="n">eigenvectors</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">(</span><span class="n">wavenumber</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="o">*</span><span class="n">eigenvectors</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wavenumber</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
            <span class="c1">#time averaged complex Poynting vector (normal component)</span>
            <span class="n">Pn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dot_eigenvectors</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1">#cross-section and time averaged energy velocity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">energy_velocity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span><span class="o">/</span><span class="n">E</span><span class="p">)</span>
        <span class="n">K1T</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computation of energy velocity, elapsed time : </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s&#39;</span><span class="p">)</span>
        
        <span class="c1"># Warning for pml problems (integration restricted on the core is currently not possible)</span>
        <span class="n">dofs_pml</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">getDiagonal</span><span class="p">()[:])</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">dofs_pml</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: the energy velocity is currently integrated on the whole domain including PML region&quot;</span><span class="p">)</span></div>
        <span class="c1">## Future works: a possible trick to restrict the integration on physical dofs</span>
        <span class="c1">#dofs_pml = np.iscomplex(M.getDiagonal()[:]) #problem: if not stuck to the core, can include part of the exterior domain</span>
        <span class="c1">#Mat = M.copy(); Mat.zeroRowsColumns(dofs_pml, diag=0) #or: eigenvectors.zeroRows(dofs_pml, diag=0)</span>

<div class="viewcode-block" id="Waveguide.compute_opposite_going"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.compute_opposite_going">[docs]</a>    <span class="k">def</span> <span class="nf">compute_opposite_going</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-process the pairing of opposite-going modes, based on wavenumber and biorthogonality criteria, and store them</span>
<span class="sd">        as a an attribute (name: opposite_going, -1 value for unpaired modes).</span>
<span class="sd">        Compute their biorthogonality normalization factors, Um^T*F-m - U-m^T*Fm, where m and -m denote opposite-going</span>
<span class="sd">        modes, for the whole parameter range and store them as an attribute (name: _biorthogonality_factor).</span>
<span class="sd">        If plot is set to True, the biorthogonality criterion found by the algorithm is plotted as a function</span>
<span class="sd">        of frequency index, allowing visual check that there is no values close to zero (a factor close to zero probably means</span>
<span class="sd">        a lack of biorthogonality). The biorthogonality criterion is defined as |biorthogonality_factor*omega/4|.</span>
<span class="sd">        </span>
<span class="sd">        Notes:</span>
<span class="sd">        </span>
<span class="sd">        - when an unpaired mode is found, the value -1 is stored in opposite_going (and NaN value in _biorthogonality_factor),</span>
<span class="sd">          meaning that this mode will be discarded in the computation of group velocity, traveling direction, coefficient and</span>
<span class="sd">          excitability (NaN values stored)</span>
<span class="sd">        - if modes with lack of biorthogonality or two many unpaired modes occur, try to recompute the eigenproblem by</span>
<span class="sd">          increasing the accuracy (e.g. reducing the tolerance)</span>
<span class="sd">        - lack of biorthogonality may be also due to multiple modes (*); in this case, try to use an unstructured mesh instead</span>
<span class="sd">        - if two_sided is True, lack of biorthogonolity may occur for specific target: try another target (e.g. add a small</span>
<span class="sd">          imaginary part)</span>
<span class="sd">           </span>
<span class="sd">        (*) e.g. flexural modes in a cylinder with structured mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tol1</span> <span class="o">=</span> <span class="mf">1e-4</span> <span class="c1">#tolerance for relative difference between opposite wavenumbers (wavenumber criterion)</span>
        <span class="n">tol2_rel</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1">#minimum ratio between the first two candidate biorthogonality factors (biorthogonality criterion)</span>
        <span class="n">tol2_abs</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="c1">#minimum biorthogonality factor to keep a given opposite pair (biorthogonality criterion)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s1">&#39;wavenumber&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">two_sided</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Computation of biorthogonality factor is not possible: opposite-going modes cannot be paired for this kind of problem (check that the problem is of omega type and that target has been set to 0)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opposite_going</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Opposite-going pairs already computed&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#compute the eigenforces if not yet computed      </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_eigenforces</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poynting_normalization</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_poynting_normalization</span><span class="p">()</span> <span class="c1">#this normalization matters for a proper use of tol2_abs, because it ensures that the biorthogonality factor x omega/4 is equal to 1 for pairs of pure propagating modes</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eigenvalues</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">):</span>
            <span class="c1">#Loop over half of complex plane</span>
            <span class="n">upper_half</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span><span class="o">&gt;=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lower_half</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">upper_half</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">opposite_going</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">biorthogonality_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">upper_half</span><span class="p">:</span>
                <span class="c1">#First criterion: based on wavenumber</span>
                <span class="n">criterion1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">+</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">lower_half</span><span class="p">])</span><span class="o">/</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>
                <span class="n">candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lower_half</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">criterion1</span><span class="o">&lt;=</span><span class="n">tol1</span><span class="p">)])</span> <span class="c1">#candidates of lower half</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#candidates found</span>
                    <span class="c1">#If only one candidate found: add a second candidate to allow the test of second criterion</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">eigenvalues</span><span class="p">[</span><span class="n">candidates</span><span class="p">]</span> <span class="c1">#store initial value</span>
                        <span class="n">eigenvalues</span><span class="p">[</span><span class="n">candidates</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1">#trick to discard the first candidate</span>
                        <span class="n">candidates2</span> <span class="o">=</span> <span class="n">lower_half</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">+</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">lower_half</span><span class="p">]))]</span> <span class="c1">#find the second candidate</span>
                        <span class="n">eigenvalues</span><span class="p">[</span><span class="n">candidates</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span> <span class="c1">#back to initial</span>
                        <span class="n">candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">candidates2</span><span class="p">)</span>
                    <span class="c1">#Second criterion: based on biorthogonality</span>
                    <span class="n">biorthogonality_test</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                        <span class="n">biorthogonality_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">biorthogonality_test</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">tDot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
                                       <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">tDot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">mode</span><span class="p">)))</span>
                    <span class="c1">#OLD: biorthogonality_test = self.eigenforces[i][:,candidates.tolist()].T @ self.eigenvectors[i][:,mode] - self.eigenvectors[i][:,candidates.tolist()].T @ self.eigenforces[i][:,mode]</span>
                    <span class="n">criterion2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">biorthogonality_test</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">criterion2</span><span class="p">)</span> <span class="c1">#sort by ascending order</span>
                    <span class="k">if</span> <span class="n">criterion2</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">&lt;</span><span class="n">tol2_rel</span><span class="o">*</span><span class="n">criterion2</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]]:</span> <span class="c1">#relative criterion</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">: Lack of biorthogonality between mode </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1"> and modes [</span><span class="si">{</span><span class="n">candidates</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]]</span><span class="si">}</span><span class="s1">], with respective biorthogonality factor [</span><span class="si">{</span><span class="n">criterion2</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]]</span><span class="si">}</span><span class="s1">]!&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">criterion2</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">&gt;</span><span class="n">tol2_abs</span><span class="p">:</span> <span class="c1">#absolute value criterion</span>
                        <span class="n">opposite</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                        <span class="n">opposite_going</span><span class="p">[[</span><span class="n">mode</span><span class="p">,</span> <span class="n">opposite</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">opposite</span><span class="p">,</span> <span class="n">mode</span><span class="p">]</span>
                        <span class="n">biorthogonality_factor</span><span class="p">[[</span><span class="n">mode</span><span class="p">,</span> <span class="n">opposite</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">biorthogonality_test</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="o">-</span><span class="n">biorthogonality_test</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span>
            <span class="c1">#Final check</span>
            <span class="n">unique</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">opposite_going</span><span class="p">[</span><span class="n">opposite_going</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">counts</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span> <span class="c1">#test for duplicate modes</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">unique</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">: duplicate modes found by the pairing process!&#39;</span><span class="p">)</span>
            <span class="n">unpaired</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">opposite_going</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unpaired</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#test for unpaired modes</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">: unpaired modes found, index=</span><span class="si">{</span><span class="n">unpaired</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">):</span> <span class="c1">#the traveling direction has already been computed but using energy velocity</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">unpaired</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
            <span class="c1">#Store pairs and biorthogonality factors</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opposite_going</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opposite_going</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_biorthogonality_factor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">biorthogonality_factor</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computation of pairs of opposite-going modes, elapsed time : </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s&#39;</span><span class="p">)</span>
        <span class="c1">#Plot biorthogonality criterion as a function of frequency index</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">egv</span><span class="p">)</span> <span class="k">for</span> <span class="n">egv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_biorthogonality_factor</span><span class="p">])</span>
            <span class="n">biorthogonality_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_biorthogonality_factor</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">biorthogonality_factor</span><span class="o">*</span><span class="n">omega</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;frequency index&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;biorthogonality criterion&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">tol2_abs</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;----- threshold allowed&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>

<div class="viewcode-block" id="Waveguide.compute_group_velocity"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.compute_group_velocity">[docs]</a>    <span class="k">def</span> <span class="nf">compute_group_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-process the group velocity, vg=1/Re(dk/domega) for every mode in the whole parameter range (opposite-going modes</span>
<span class="sd">        required). For unpaired modes, NaN values are set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group_velocity</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Group velocity already computed&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opposite_going</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#compute opposite-going modes if not yet computed      </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_opposite_going</span><span class="p">()</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span> <span class="c1">#ignore divide by zero message (denominator may sometimes vanish) </span>
        <span class="n">K1T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="c1">#K1^T is stored before loop (faster computations)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">)):</span>
            <span class="c1">#Computation of group velocity</span>
            <span class="n">wavenumber</span><span class="p">,</span> <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concatenate</span><span class="p">(</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">,</span> <span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="c1">#repeat parameter as many times as the number of eigenvalues</span>
            <span class="n">group_velocity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
            <span class="n">numerator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">*</span><span class="n">eigenvectors</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="o">*</span><span class="n">eigenvectors</span> <span class="c1">#note: computing the denominator can probably be avoided if _compute_biorthogonality_factor() has already been done</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="n">denominator</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">(</span><span class="n">wavenumber</span><span class="p">)</span>
            <span class="n">denominator</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">K1</span><span class="o">*</span><span class="n">eigenvectors</span>
            <span class="n">denominator</span> <span class="o">-=</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">K1T</span><span class="o">*</span><span class="n">eigenvectors</span>
            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">opposite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opposite_going</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">mode</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">opposite</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#the mode has been successfully paired</span>
                    <span class="n">uleft</span> <span class="o">=</span> <span class="n">eigenvectors</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">opposite</span><span class="p">)</span>
                    <span class="n">group_velocity</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">*</span><span class="n">numerator</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span><span class="o">.</span><span class="n">tDot</span><span class="p">(</span><span class="n">uleft</span><span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span><span class="o">.</span><span class="n">tDot</span><span class="p">(</span><span class="n">uleft</span><span class="p">)</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">group_velocity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_velocity</span><span class="p">)</span>
        <span class="n">K1T</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computation of group velocity, elapsed time : </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Waveguide.compute_traveling_direction"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.compute_traveling_direction">[docs]</a>    <span class="k">def</span> <span class="nf">compute_traveling_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-process the traveling direction, +1 or -1, for every mode in the whole parameter range,</span>
<span class="sd">        using the sign of Im(k + 1j*delta/v) where delta is the imaginary shift used for analytical</span>
<span class="sd">        continuation of k, and v is the group velocity (or, if not available, the energy velocity).</span>
<span class="sd">        This criterion is based on the limiting absorption principle (theoretically, vg should be used</span>
<span class="sd">        instead of ve). For unpaired modes, NaN values are set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Traveling direction already computed&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group_velocity</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_velocity</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#both group velocity and energy velocity have not been already computed</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opposite_going</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_energy_velocity</span><span class="p">()</span> <span class="c1">#the energy velocity is simpler to compute (the pairing of opposite-going is not required)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_group_velocity</span><span class="p">()</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span> <span class="c1">#ignore divide by zero message (denominator may sometimes vanish)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">)):</span>
            <span class="n">wavenumber</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concatenate</span><span class="p">(</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">delta</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_velocity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group_velocity</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_velocity</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wavenumber</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wavenumber</span><span class="o">.</span><span class="n">real</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#do not use the LAP if |Im(k)| + |delta/ve| is significant</span>
            <span class="n">traveling_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">((</span><span class="n">wavenumber</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">temp</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traveling_direction</span><span class="p">)</span>
            <span class="c1">#Check if any exponentially growing modes (in the numerical LAP, delta is user-defined, which might lead to wrong traveling directions)</span>
            <span class="n">growing_modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">wavenumber</span><span class="o">.</span><span class="n">imag</span><span class="o">*</span><span class="n">traveling_direction</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wavenumber</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">1e-6</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wavenumber</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">growing_modes</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning in computing traveling direction: exponentially growing modes found (unproper sign of Im(k) detected)&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;for iteration </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">, with |Im(k)/Re(k)| up to </span><span class="si">{</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wavenumber</span><span class="p">[</span><span class="n">growing_modes</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="o">/</span><span class="n">wavenumber</span><span class="p">[</span><span class="n">growing_modes</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computation of traveling direction, elapsed time : </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Waveguide.compute_pml_ratio"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.compute_pml_ratio">[docs]</a>    <span class="k">def</span> <span class="nf">compute_pml_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-process the pml ratio (useful to filter out PML mode), given by 1-Im(Ek)/|Ek| where Ek denotes</span>
<span class="sd">        the &quot;complex&quot; kinetic energy, for every mode in the whole parameter range.      </span>
<span class="sd">        Reminder: the pml ratio tends to 1 for mode shapes vanishing inside the PML.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pml_ratio</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;PML ratio already computed&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">):</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concatenate</span><span class="p">(</span><span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="n">Ek</span> <span class="o">=</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dot_eigenvectors</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">*</span><span class="n">eigenvectors</span><span class="p">)</span> <span class="c1">#&quot;complex&quot; kinetic energy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pml_ratio</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">Ek</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Ek</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computation of pml ratio, elapsed time : </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Waveguide.compute_response_coefficient"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.compute_response_coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">compute_response_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wavenumber_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computation of modal coefficients due to the excitation vector F for every mode in the whole omega range (opposite-going</span>
<span class="sd">        eigenvectors are required).</span>
<span class="sd">        Modal coefficients qm are defined from: U(z,omega) = sum qm(omega)*Um(omega)*exp(i*km*z), m=1...M, omega denotes the</span>
<span class="sd">        angular frequency.</span>
<span class="sd">        For unpaired modes, NaN values are set.</span>
<span class="sd">        Assumption: the source is centred at z=0.</span>
<span class="sd">        </span>
<span class="sd">        Note: spectrum and wavenumber_function can be specified in compute_response(...) instead of     </span>
<span class="sd">        compute_response_coefficient(...), but not in both functions in the same time (otherwise the excitation will be</span>
<span class="sd">        modulated twice)</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        F : PETSc vector</span>
<span class="sd">            SAFE excitation vector</span>
<span class="sd">        spectrum : numpy.ndarray</span>
<span class="sd">            when specified, spectrum is a vector of length omega  used to modulate F in terms of frequency (default: 1 for</span>
<span class="sd">            all frequencies)</span>
<span class="sd">        wavenumber_function: python function</span>
<span class="sd">            when specified, wavenumber_function is a python function used to modulate F in terms of wavenumber (example:</span>
<span class="sd">            wavenumber_function = lambda x: np.sin(x), default: 1 for all wavenumbers, i.e. source localized at z=0)</span>
<span class="sd">        dof : int</span>
<span class="sd">            when specified, it calculates the modal excitability (stored in the attribute excitability), i.e. qm*Um at</span>
<span class="sd">            the degree of freedom dof and for a unit excitation vector (i.e. such that the sum of the elements of F is</span>
<span class="sd">            equal to 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Initialization</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Response coefficient computation not implemented in case wavenumber is parameter&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="n">F</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#re-initialized every time compute_response_coefficient(..) is executed (F is an input)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excitability</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#idem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complex_power</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#idem</span>
        <span class="k">if</span> <span class="n">spectrum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wavenumber_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wavenumber_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">k</span>
        <span class="k">if</span> <span class="n">dof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1">#summing elements of F amounts to integrate the (normal) stress over the cross-section </span>
        
        <span class="c1">#Check</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;The length of spectrum must be equal to the length of omega&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;dof must be an integer&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opposite_going</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#compute opposite-going modes if not yet computed      </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_opposite_going</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#compute traveling direction if not yet computed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_traveling_direction</span><span class="p">()</span>
        
        <span class="c1">#Modal coefficients (loop over frequency)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">opposite_going</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opposite_going</span><span class="p">):</span>
            <span class="n">coefficient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="n">F</span><span class="p">)</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">opposite_going</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">coefficient</span><span class="p">[</span><span class="n">mode</span><span class="p">[</span><span class="n">opposite_going</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="c1">#coefficients of unpaired modes are set to NaN</span>
            <span class="n">mode</span><span class="p">,</span> <span class="n">opposite</span> <span class="o">=</span> <span class="n">mode</span><span class="p">[</span><span class="n">opposite_going</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">],</span> <span class="n">opposite_going</span><span class="p">[</span><span class="n">opposite_going</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#consider paired modes only</span>
            <span class="n">coefficient</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">coefficient</span><span class="p">[</span><span class="n">opposite</span><span class="p">]</span>
            <span class="n">coefficient</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">coefficient</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_biorthogonality_factor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">mode</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">mode</span><span class="p">]</span>
            <span class="n">coefficient</span> <span class="o">=</span> <span class="n">coefficient</span><span class="o">*</span><span class="n">spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">wavenumber_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coefficient</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">excitability</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coefficient</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">dof</span><span class="p">,:]</span><span class="o">/</span><span class="n">force</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computation of response coefficient, elapsed time : </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s&#39;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Waveguide.compute_complex_power"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.compute_complex_power">[docs]</a>    <span class="k">def</span> <span class="nf">compute_complex_power</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-process the individual complex power flow of modes given by P=-1j*omega/2*U^H*F (normal</span>
<span class="sd">        component of complex Poynting vector), where U and F denote the eigenvector </span>
<span class="sd">        and eigenforce of a single mode. The &#39;usual&#39; power is given by the real part.</span>
<span class="sd">        </span>
<span class="sd">        Notes:</span>

<span class="sd">        - For lossy media (e.g. with viscoelasticity or with PML), it should be reminded that the individual power</span>
<span class="sd">          should be carefully handled: the power of a sum is not equal to the sum of powers because Auld&#39;s complex</span>
<span class="sd">          biorthogonality relation does no longer hold</span>
<span class="sd">        - This inequality also generally applies between two multiple modes if any(*); in this case,</span>
<span class="sd">          try to use an unstructured mesh instead?</span>
<span class="sd">        - Warning in case of PML: integration is currently done over the whole cross-section (see also</span>
<span class="sd">          compute_energy_velocity), the so-defined complex power flow is questionable</span>
<span class="sd">        </span>
<span class="sd">        (*) e.g. flexural modes in a cylinder with structured mesh, whether the medium is lossy or lossless </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complex_power</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Complex power flow already computed&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#response already computed</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Power computation has to be applied after coefficient computation&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#compute the eigenforces if not yet computed      </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_eigenforces</span><span class="p">()</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">)):</span>
            <span class="c1">#repeat parameter as many times as the number of eigenvalues</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concatenate</span><span class="p">(</span><span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="c1">#complex power flow of modes</span>
            <span class="n">complex_power</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
                <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
                <span class="n">complex_power</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">mode</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">complex_power</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">complex_power</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computation of complex power flow, elapsed time : </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s&#39;</span><span class="p">)</span>

        <span class="c1"># Warning for pml problems (integration restricted on the core is currently not possible)</span>
        <span class="n">dofs_pml</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">getDiagonal</span><span class="p">()[:])</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">dofs_pml</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: the complex power flow is currently integrated on the whole domain including PML region&quot;</span><span class="p">)</span></div>
        <span class="c1">## Future works: a possible trick to restrict the integration on physical dofs</span>
        <span class="c1">#dofs_pml = np.iscomplex(M.getDiagonal()[:]) #problem: if not stuck to the core, can include part of the exterior domain</span>
        <span class="c1">#Mat = M.copy(); Mat.zeroRowsColumns(dofs_pml, diag=0) #or: eigenvectors.zeroRows(dofs_pml, diag=0)</span>
    
<div class="viewcode-block" id="Waveguide.compute_response"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.compute_response">[docs]</a>    <span class="k">def</span> <span class="nf">compute_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dof</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">omega_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wavenumber_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-process the response (modal expansion) at the degree of freedom dof and the axial coordinate z, for the whole</span>
<span class="sd">        frequency range.</span>
<span class="sd">        The outputs are frequency, a numpy 1d array of size len(omega), and response, a numpy 2d array of size len(dof or</span>
<span class="sd">        z)*len(omega).</span>
<span class="sd">        dof and z cannot be both vectors, except if omega_index is specified or omega is scalar (single frequency computation):</span>
<span class="sd">        in that case, the array response is of size len(z)*len(dof), which can be useful to plot the whole field at a single</span>
<span class="sd">        frequency.</span>
<span class="sd">        </span>
<span class="sd">        The response at each frequency omega is calculated from:</span>
<span class="sd">        U(z,omega) = sum qm(omega)*Um(omega)*exp(i*km*z), m=1...M,</span>
<span class="sd">        where z is the receiver position along the waveguide axis.</span>
<span class="sd">        M is the number of modes traveling in the proper direction, positive if z is positive, negative if z is negative.</span>
<span class="sd">        The pairing of opposite-going eigenvectors is required, unpaired modes are discarded from the expansion.</span>
<span class="sd">        </span>
<span class="sd">        The outputs frequency and response are made dimensional when values in plot_scaler are not set to 1.</span>
<span class="sd">        </span>
<span class="sd">        Assumption: the source is assumed to be centred at z=0.</span>
<span class="sd">        </span>
<span class="sd">        Warning: the response calculation is only valid if z lies oustide the source region.</span>
<span class="sd">        </span>
<span class="sd">        Note: spectrum and wavenumber_function can be specified in compute_response_coefficient(...) instead</span>
<span class="sd">        of compute_response(...), but not in both functions in the same time (otherwise the excitation will be modulated twice).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dof : numpy array of integer</span>
<span class="sd">            dof where the response is computed</span>
<span class="sd">        z : numpy array</span>
<span class="sd">            axial coordinate where the response is computed</span>
<span class="sd">        omega_index : int</span>
<span class="sd">            omega index to compute the response at a single frequency, allowing the consideration of multiple dof and z</span>
<span class="sd">        spectrum : numpy.ndarray</span>
<span class="sd">            when specified, spectrum is a vector of length omega  used to modulate F in terms of frequency (default: 1 for</span>
<span class="sd">            all frequencies)</span>
<span class="sd">        wavenumber_function: python function</span>
<span class="sd">            when specified, wavenumber_function is a python function used to modulate F in terms of wavenumber (example:</span>
<span class="sd">            wavenumber_function = lambda x: np.sin(x), default: 1 for all wavenumbers, i.e. source localized at z=0)</span>
<span class="sd">        plot : bool</span>
<span class="sd">            if set to True, the magnitude and phase of response are plotted as a function of frequency</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        frequency : numpy 1d array</span>
<span class="sd">            the frequency vector, i.e. omega/(2*pi)</span>
<span class="sd">        response : numpy array (1d or 2d)</span>
<span class="sd">            the matrix response</span>
<span class="sd">        ll_abs : matplotlib list of lines for magnitude plot when plot is set to True</span>
<span class="sd">        ll_angle : matplotlib list of lines for phase plot when plot is set to True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#Initialization</span>
        <span class="n">response</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dof</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">omega_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">omega_index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">omega_index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span> <span class="c1">#single element special case</span>
                <span class="n">omega_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">omega_index</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;omega_index must be an integer&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spectrum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        
        <span class="c1">#Check</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Response computation not implemented in case wavenumber is parameter&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">omega_index</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Plot is not possible for a single frequency computation (please set plot to False)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;The length of spectrum must be equal to the length of omega&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">z</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;z cannot contain zero values (z must lie outside the source region)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wavenumber_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reminder: z should lie outside the source region&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wavenumber_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wavenumber_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">k</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">direction</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">!=</span><span class="n">direction</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;z cannot contain both negative and positive values&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dof</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">z</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">omega_index</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;dof and z cannot be both vectors in the same time except for a single frequency computation&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#response coefficient has not yet been computed</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Response coefficient must be computed first (execute compute_response_coefficient(...))&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="c1">#Response</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">omega_index</span><span class="p">:</span>
            <span class="n">imode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">direction</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="c1">#indices of modes traveling in the desired direction</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">imode</span><span class="p">]</span><span class="o">*</span><span class="n">spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">wavenumber_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">imode</span><span class="p">])</span>
            <span class="c1">#temp = (self.eigenvectors[i][dof.tolist(),imode] @ np.diag(temp)) @ np.exp(1j*np.outer(self.eigenvalues[i][imode], z)) #OLD: np.diag(temp) may have many zeros</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">createDense</span><span class="p">([</span><span class="n">dof</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">imode</span><span class="p">)],</span> <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">dof</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span><span class="n">imode</span><span class="p">],</span> <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[:,:]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">imode</span><span class="p">],</span> <span class="n">z</span><span class="p">))</span> <span class="c1">#note: PETSc matrices have no exponential function (although PETSc vectors have one!) -&gt; going back to numpy arrays here for simplicity...</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#enforce vector to be column</span>
            <span class="n">response</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="c1">#numpy array of size len(dof or z)*len(self.omega)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">omega_index</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dof</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="c1">#numpy array of size len(z)*len(dof)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computation of response, elapsed time : </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s&#39;</span><span class="p">)</span>
        <span class="n">frequency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">omega_index</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        
        <span class="c1"># Scaling</span>
        <span class="n">xscale</span><span class="p">,</span> <span class="n">yscale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">]</span>
        <span class="n">frequency</span><span class="p">,</span> <span class="n">response</span> <span class="o">=</span> <span class="n">frequency</span><span class="o">*</span><span class="n">xscale</span><span class="p">,</span> <span class="n">response</span><span class="o">*</span><span class="n">yscale</span>
        
        <span class="c1">#Plots</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span> <span class="c1">#the dictionnary variables are equal to 1</span>
                <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;normalized angular frequency&quot;</span><span class="p">,</span> <span class="s2">&quot;|normalized displacement|&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">xscale</span> <span class="o">=</span> <span class="s2">&quot;frequency&quot;</span><span class="p">,</span> <span class="s2">&quot;|displacement|&quot;</span><span class="p">,</span> <span class="n">xscale</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="c1">#Magnitude</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ll_abs</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">real</span><span class="o">*</span><span class="n">xscale</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">)</span> <span class="c1">#color=&quot;k&quot;</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="c1">#Phase</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ll_angle</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">real</span><span class="o">*</span><span class="n">xscale</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">)</span> <span class="c1">#color=&quot;k&quot;</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">ll_abs</span><span class="p">,</span> <span class="n">ll_angle</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">response</span></div>

<div class="viewcode-block" id="Waveguide.track_mode"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.track_mode">[docs]</a>    <span class="k">def</span> <span class="nf">track_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega_index</span><span class="p">,</span> <span class="n">mode_index</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Track a mode over the whole frequency range.</span>
<span class="sd">        The mode is specified by its index, mode_index, at a given angular frequency index, omega_index.</span>
<span class="sd">        Tracking is performed thanks to similarity between eigenvectors and eigenforces (value between 0 and 1).</span>
<span class="sd">        Tracking is stopped if similarity becomes lower than threshold.</span>
<span class="sd">        It returns mode, the index list identifying the mode position at each frequency (index is set to -1</span>
<span class="sd">        for frequencies at which the mode has not been successfully tracked due to low similarity).</span>
<span class="sd">        If plot is set to True, the real and imaginary parts of eigenvalue are plotted w.r.t. frequency index,</span>
<span class="sd">        for visual check that the desired mode has been properly tracked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#compute the eigenforces if not yet computed      </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_eigenforces</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#compute traveling direction if not yet computed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_traveling_direction</span><span class="p">()</span>
        
        <span class="c1">#Initialization</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">#fill with -1 by default</span>
        <span class="n">mode</span><span class="p">[</span><span class="n">omega_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode_index</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="p">[</span><span class="n">omega_index</span><span class="p">][</span><span class="n">mode_index</span><span class="p">]</span>
        <span class="n">upper_part</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">omega_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#towards increasing frequency</span>
        <span class="n">lower_part</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">omega_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#towards decreasing frequency</span>
        
        <span class="c1">#Track mode based on similarity</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">upper_part</span><span class="p">,</span> <span class="n">lower_part</span><span class="p">]):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">mode_index</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
                <span class="n">inext</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span> <span class="c1">#i+1 if p=0 (upper part), i-1 if p=1 (lower part)</span>
                <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">F</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">similarity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">inext</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">imodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="p">[</span><span class="n">inext</span><span class="p">]</span><span class="o">==</span><span class="n">direction</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#restriction to modes traveling in the same direction</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">imodes</span><span class="p">:</span>
                    <span class="n">test_U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">inext</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                    <span class="n">test_F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">[</span><span class="n">inext</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                    <span class="n">similarity</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">test_U</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="o">+</span> <span class="n">test_F</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">F</span><span class="p">))</span> \
                                  <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">U</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">F</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">test_U</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">test_F</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">similarity</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">&lt;</span><span class="n">threshold</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Mode tracking stopped at frequency index </span><span class="si">{</span><span class="n">inext</span><span class="si">}</span><span class="s1">: similarity equals </span><span class="si">{</span><span class="n">similarity</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">, lower than threshold (try to increase threshold)&#39;</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">similarity</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
                    <span class="n">mode</span><span class="p">[</span><span class="n">inext</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
        
        <span class="c1">#Plot for check</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">eigenvalues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">mode</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;real&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;imag&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;frequency index&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;eigenvalue&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;tracked mode curve&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mode</span></div>

<div class="viewcode-block" id="Waveguide.plot_phase_velocity"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.plot_phase_velocity">[docs]</a>    <span class="k">def</span> <span class="nf">plot_phase_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot phase velocity dispersion curves, vp vs. Re(omega), where omega is replaced with frequency</span>
<span class="sd">        for dimensional results. Parameters and Returns: see plot(...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;phase_velocity&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Waveguide.plot_attenuation"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.plot_attenuation">[docs]</a>    <span class="k">def</span> <span class="nf">plot_attenuation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot attenuation dispersion curves, Im(wavenumber) vs. Re(omega) if omega is the parameter,</span>
<span class="sd">        or Im(omega) vs. Re(wavenumber) if wavenumber is the parameter, where omega is replaced with frequency</span>
<span class="sd">        for dimensional results. Parameters and Returns: see plot(...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;attenuation&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Waveguide.plot_energy_velocity"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.plot_energy_velocity">[docs]</a>    <span class="k">def</span> <span class="nf">plot_energy_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot energy velocity dispersion curves, ve vs. Re(omega), where omega is replaced with frequency</span>
<span class="sd">        for dimensional results. Parameters and Returns: see plot(...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;energy_velocity&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Waveguide.plot_group_velocity"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.plot_group_velocity">[docs]</a>    <span class="k">def</span> <span class="nf">plot_group_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot group velocity dispersion curves, vg vs. Re(omega), where omega is replaced with frequency</span>
<span class="sd">        for dimensional results. Parameters and Returns: see plot(...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;group_velocity&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Waveguide.plot_coefficient"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.plot_coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">plot_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot response coefficients as a function of frequency, |q| vs. Re(omega), where omega is replaced with frequency</span>
<span class="sd">        for dimensional results. Parameters and Returns: see plot(...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;coefficient&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Waveguide.plot_excitability"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.plot_excitability">[docs]</a>    <span class="k">def</span> <span class="nf">plot_excitability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot excitability as a function of frequency, |e| vs. Re(omega), where omega is replaced with frequency</span>
<span class="sd">        for dimensional results. Parameters and Returns: see plot(...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;excitability&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Waveguide.plot_complex_power"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.plot_complex_power">[docs]</a>    <span class="k">def</span> <span class="nf">plot_complex_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot complex power flow of individual modes as a function of frequency, Re(P) and Im(P) vs. Re(omega), </span>
<span class="sd">        where omega is replaced with frequency for dimensional results. Gray color is used for the imaginary part.</span>
<span class="sd">        Parameters and Returns: see plot(...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;complex_power&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Im&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;complex_power&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Re&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sc</span></div>
    
<div class="viewcode-block" id="Waveguide.plot"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pml_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot dispersion curves y[1](y[0]) vs. x[1](x[0]) as scatter plot.</span>
<span class="sd">        If the index list, mode, is specified by the user, a single mode is plotted as a continuous single colored curve</span>
<span class="sd">        (the index list mode can be obtained from method track_mode(...)).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y, c: list</span>
<span class="sd">            x[0], y[0], c[0] are strings corresponding to modal properties for the x-axis, y-axis and marker colors respectively</span>
<span class="sd">            (these strings can be: &#39;omega&#39;, &#39;wavenumber&#39;, &#39;energy_velocity&#39;, &#39;group_velocity&#39;, &#39;pml_ratio&#39;, &#39;eigenvalues&#39;,</span>
<span class="sd">            &#39;excitability&#39;, &#39;eigenvectors&#39;, &#39;eigenforces&#39;, &#39;coefficient&#39;, &#39;power flow&#39;, &#39;frequency&#39;, &#39;attenuation&#39;, &#39;phase_velocity&#39;),</span>
<span class="sd">            x[1], y[1], c[1] are the functions applied to x[0], y[0] and c[0] respectively (e.g. np.abs, np.angle, np.real, np.imag, etc.).</span>
<span class="sd">            If x is None but not y, x is set to [&#39;omega&#39;, np.real] if results are normalized, or set to [&#39;frequency&#39;, np.real] if they are</span>
<span class="sd">            dimensional. If both x and are None, plot dispersion curves Re(omega) or Re(frequency) vs. Re(wavenumber).</span>
<span class="sd">            If c is None, a single color is used for coloring markers (given by the input variable color).</span>
<span class="sd">        direction: int</span>
<span class="sd">            +1 for positive-going modes, -1 for negative-going modes, None for plotting all modes</span>
<span class="sd">        pml_threshold: float</span>
<span class="sd">            threshold to filter out PML modes (modes such that pml_ratio&lt;pml_threshold)</span>
<span class="sd">        mode: index list</span>
<span class="sd">            index list identifying the mode position at each frequency</span>
<span class="sd">        ax: matplotlib axis</span>
<span class="sd">            the matplotlib axis on which to plot data (created if None)</span>
<span class="sd">        color: str, marker: str, markersize: int, linestyle: str, **kwargs are passed to ax.plot</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sc: the matplotlib collection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_if_necessary</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">pml_threshold</span><span class="p">)</span> <span class="c1">#compute traveling direction and pml ratio if necessary</span>
        <span class="n">normalized</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#test if the dictionnary variables are equal to 1 (results will be normalized) or not (results will be dimensional)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#particular cases</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;omega&#39;</span> <span class="k">if</span> <span class="n">normalized</span> <span class="k">else</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;attenuation&#39;</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;omega&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s1">&#39;omega&#39;</span> <span class="k">else</span> <span class="s1">&#39;wavenumber&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s1">&#39;omega&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">normalized</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;frequency&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;omega&#39;</span> <span class="k">if</span> <span class="n">normalized</span> <span class="k">else</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;coefficient&#39;</span><span class="p">,</span> <span class="s1">&#39;excitability&#39;</span><span class="p">,</span> <span class="s1">&#39;complex_power&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;No &#39;</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; has been computed&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;coefficient&#39;</span><span class="p">,</span> <span class="s1">&#39;excitability&#39;</span><span class="p">,</span> <span class="s1">&#39;complex_power&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;No &#39;</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; has been computed&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;energy_velocity&#39;</span><span class="p">,</span> <span class="s1">&#39;group_velocity&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;self.compute_&#39;</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;()&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;energy_velocity&#39;</span><span class="p">,</span> <span class="s1">&#39;group_velocity&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;self.compute_&#39;</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;()&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pml_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Do not give any direction or pml_threshold when mode is specified&#39;</span><span class="p">)</span>
        
        <span class="c1"># Scaling and labels</span>
        <span class="n">xscale</span><span class="p">,</span> <span class="n">yscale</span><span class="p">,</span> <span class="n">cscale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">xlabel</span> <span class="o">=</span> <span class="s1">&#39;angular frequency&#39;</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;omega&#39;</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="c1">#take the string x and replace underscores with whitespaces</span>
        <span class="n">ylabel</span> <span class="o">=</span> <span class="s1">&#39;angular frequency&#39;</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;omega&#39;</span> <span class="k">else</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="c1">#id</span>
        <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span> <span class="c1">#add string &quot;normalized&quot; to labels</span>
            <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;normalized &quot;</span> <span class="o">+</span> <span class="n">xlabel</span><span class="p">,</span> <span class="s2">&quot;normalized &quot;</span> <span class="o">+</span> <span class="n">ylabel</span>
        
        <span class="c1"># Build concatenaded arrays from the string x[0] and apply functions x[1] (idem for y and c)</span>
        <span class="n">x_array</span><span class="p">,</span> <span class="n">y_array</span><span class="p">,</span> <span class="n">c_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concatenate</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">pml_threshold</span><span class="o">=</span><span class="n">pml_threshold</span><span class="p">)</span>
        <span class="n">x_array</span><span class="p">,</span> <span class="n">y_array</span><span class="p">,</span> <span class="n">c_array</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">x_array</span><span class="o">*</span><span class="n">xscale</span><span class="p">),</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">y_array</span><span class="o">*</span><span class="n">yscale</span><span class="p">),</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">c_array</span><span class="o">*</span><span class="n">cscale</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#single color plot (no colorbar)</span>
            <span class="n">c_array</span> <span class="o">=</span> <span class="n">color</span>
        
        <span class="c1"># Plot</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#all modes</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span> <span class="n">y_array</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">markersize</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c_array</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">#single mode (trick to find the right index)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">mode</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_array</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">y_array</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="n">markersize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1">#here, sc should be understood as ll (line of lines)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="c1"># plt.show()  #let user decide whether he wants to interrupt the execution for display, or save to figure...</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="c1">#label=colors</span>
        <span class="k">return</span> <span class="n">sc</span></div>

<div class="viewcode-block" id="Waveguide.set_plot_scaler"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.set_plot_scaler">[docs]</a>    <span class="k">def</span> <span class="nf">set_plot_scaler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mass</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define the characteristic length, time and mass in order to visualize plots in a dimensional form (by default, they are equal to 1).</span>
<span class="sd">        Set dim=3 for three-dimensional waveguides, dim=2 for two-dimensional waveguides (e.g. plates).</span>
<span class="sd">        Scaling factors for &#39;omega&#39;, &#39;wavenumber&#39;, &#39;energy_velocity&#39;, &#39;group_velocity&#39;, &#39;pml_ratio&#39;, &#39;eigenvalues&#39;, &#39;excitability&#39;,</span>
<span class="sd">        &#39;eigenvectors&#39;, &#39;eigenforces&#39;, &#39;coefficient&#39;, &#39;complex_power&#39;, &#39;frequency&#39;, &#39;attenuation&#39;, &#39;phase_velocity&#39; are stored in the</span>
<span class="sd">        attribute name plot_scaler.</span>
<span class="sd">        If poynting normalization has already been applied, then the scalers for &#39;eigenvectors&#39;, &#39;eigenforces&#39; and &#39;coefficient&#39; are such that</span>
<span class="sd">        the dimensional cross-section power flow of eigenmodes is equal to 1 Watt (if no poynting normalization applied, these scalers are</span>
<span class="sd">        left to 1).</span>
<span class="sd">        Reminder: while the dimension of U (displacement) is in meter, the dimension of F (force) is in Newton for 3D waveguides</span>
<span class="sd">        and in Newton/meter for 2D waveguides (F is in mass*length**(dim-2)/time**2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">force</span> <span class="o">=</span> <span class="n">mass</span><span class="o">*</span><span class="n">length</span><span class="o">**</span><span class="p">(</span><span class="n">dim</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">time</span><span class="o">**</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;omega&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="n">time</span><span class="p">,</span> <span class="s1">&#39;wavenumber&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="n">length</span><span class="p">,</span> <span class="s1">&#39;energy_velocity&#39;</span><span class="p">:</span><span class="n">length</span><span class="o">/</span><span class="n">time</span><span class="p">,</span> <span class="s1">&#39;group_velocity&#39;</span><span class="p">:</span><span class="n">length</span><span class="o">/</span><span class="n">time</span><span class="p">,</span> <span class="s1">&#39;pml_ratio&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                            <span class="s1">&#39;eigenvalues&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="n">length</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s1">&#39;omega&#39;</span> <span class="k">else</span> <span class="mi">1</span><span class="o">/</span><span class="n">time</span><span class="p">,</span> <span class="s1">&#39;excitability&#39;</span><span class="p">:</span><span class="n">length</span><span class="o">/</span><span class="n">force</span><span class="p">,</span>
                            <span class="s1">&#39;eigenvectors&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eigenforces&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;coefficient&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;complex_power&#39;</span><span class="p">:</span><span class="n">force</span><span class="o">*</span><span class="n">length</span><span class="o">/</span><span class="n">time</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;frequency&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">],</span> <span class="s1">&#39;attenuation&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="s1">&#39;eigenvalues&#39;</span><span class="p">],</span> <span class="s1">&#39;phase_velocity&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="s1">&#39;energy_velocity&#39;</span><span class="p">]})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poynting_normalization</span><span class="p">:</span>
            <span class="n">normalization_factor_1W</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">force</span><span class="o">*</span><span class="n">length</span><span class="o">/</span><span class="n">time</span><span class="p">)</span> <span class="c1">#factor to normalize eigenmodes such that their dimensional cross-section power flow is equal to 1 Watt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;eigenvectors&#39;</span><span class="p">:</span><span class="n">normalization_factor_1W</span><span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="s1">&#39;eigenforces&#39;</span><span class="p">:</span><span class="n">normalization_factor_1W</span><span class="o">*</span><span class="n">force</span><span class="p">,</span> <span class="s1">&#39;coefficient&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="n">normalization_factor_1W</span><span class="p">})</span></div>

<div class="viewcode-block" id="Waveguide.plot_spectrum"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Waveguide.plot_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">plot_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the spectrum, Im(k) vs. Re(k) computed for omega[index] (if the parameter is the frequency),</span>
<span class="sd">        or Im(omega) vs. Re(omega) for wavenumber[index] (if the parameter is the wavenumber).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index: int</span>
<span class="sd">            parameter index</span>
<span class="sd">        c: list</span>
<span class="sd">            c[0] is a string (must be an attribute of self) and c[1] is a function used for coloring markers,</span>
<span class="sd">            a single color (given by the input variable color) is used if c is None</span>
<span class="sd">        ax: matplotlib axis</span>
<span class="sd">            the matplotlib axis on which to plot data (created if None)</span>
<span class="sd">        color: str, marker: str, markersize: int, linestyle: str, **kwargs are passed to ax.plot</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sc: the matplotlib collection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">normalized</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;wavenumber&quot;</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;normalized angular frequency&quot;</span> <span class="k">if</span> <span class="n">normalized</span> <span class="k">else</span> <span class="s2">&quot;angular frequency&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;omega&quot;</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;normalized wavenumber&quot;</span> <span class="k">if</span> <span class="n">normalized</span> <span class="k">else</span> <span class="s2">&quot;wavenumber&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="n">index</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">color</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">markersize</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;real part&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;imaginary part&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">color</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="c1">#label=colors</span>
        <span class="k">return</span> <span class="n">sc</span></div>

    <span class="k">def</span> <span class="nf">_check_biorthogonality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return and plot, for the ith parameter, the Modal Assurance Criterion (MAC) matrix based on the (bi)-orthogonality relation (for internal use)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#the eigenforces has not yet been computed</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigenforces have not yet been computed&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;wavenumber&quot;</span><span class="p">:</span>
            <span class="n">biorthogonality</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">hermitianTranspose</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1">#hyp: K0, K1, K2, M and eigenvalues must be real here!</span>
            <span class="c1"># Warning for lossy problems</span>
            <span class="n">dofs_complex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="o">.</span><span class="n">getDiagonal</span><span class="p">()[:])</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">dofs_complex</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: the orthogonality relation implemented is valid for real matrices only (lossless problems)&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;omega&quot;</span><span class="p">:</span>
            <span class="n">biorthogonality</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenforces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">biorthogonality</span><span class="p">[:,:]))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;MAC matrix for iteration </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">biorthogonality</span>

    <span class="k">def</span> <span class="nf">_get_eigenpairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">two_sided</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all converged eigenpairs of the current EVP object (for internal use).</span>
<span class="sd">        Eigenvectors are stored in a PETSc dense matrix.</span>
<span class="sd">        If two_sided is set to True, left eigensolutions are also included in the outputs, removing any duplicates.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">nconv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">getConverged</span><span class="p">()</span>
        <span class="c1">#Initialization</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s1">&#39;omega&#39;</span> <span class="ow">and</span> <span class="n">two_sided</span><span class="p">:</span> <span class="c1">#get rid of one half of complex plane to avoid duplicates</span>
            <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">getEigenpair</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nconv</span><span class="p">)])</span>
            <span class="n">modes_kept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span><span class="o">&gt;-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">#keep all</span>
            <span class="n">modes_kept</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nconv</span><span class="p">)</span> 
        <span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">getOperators</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">createVecRight</span><span class="p">()</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">getSize</span><span class="p">())</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">getSize</span><span class="p">()</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">getSize</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">getSize</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="c1">#1/2 in case of externally linearized quadratic evp</span>
        <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">eigenvectors</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="s2">&quot;dense&quot;</span><span class="p">)</span>
        <span class="n">eigenvectors</span><span class="o">.</span><span class="n">setSizes</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">getSize</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">modes_kept</span><span class="p">)</span> <span class="k">if</span> <span class="n">two_sided</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">modes_kept</span><span class="p">)])</span>
        <span class="n">eigenvectors</span><span class="o">.</span><span class="n">setFromOptions</span><span class="p">()</span>
        <span class="n">eigenvectors</span><span class="o">.</span><span class="n">setUp</span><span class="p">()</span>
        <span class="c1">#Build eigenpairs</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">modes_kept</span><span class="p">):</span>
            <span class="n">eigenvalues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">getEigenpair</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s1">&#39;omega&#39;</span> <span class="ow">and</span> <span class="n">two_sided</span><span class="p">:</span> <span class="c1">#include left eigensolutions</span>
                <span class="n">eigenvectors</span><span class="o">.</span><span class="n">setValues</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">evp</span><span class="o">.</span><span class="n">getLeftEigenvector</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">v</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="c1">#cancel the conjugate internally applied by SLEPc</span>
                <span class="n">eigenvectors</span><span class="o">.</span><span class="n">setValues</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                <span class="n">eigenvalues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">eigenvalues</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eigenvectors</span><span class="o">.</span><span class="n">setValues</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="n">eigenvectors</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>
        <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s2">&quot;wavenumber&quot;</span><span class="p">:</span>
            <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span>

    <span class="k">def</span> <span class="nf">_concatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pml_threshold</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return concatenated modal properties in the whole parameter range as 1D numpy arrays (for internal use).</span>
<span class="sd">        The arguments *args are strings which can be &#39;omega&#39;, &#39;wavenumber&#39;, &#39;energy_velocity&#39;, &#39;group_velocity&#39;,</span>
<span class="sd">        &#39;pml_ratio&#39;, &#39;eigenvalues&#39;, &#39;excitability&#39;, &#39;eigenvectors&#39;, &#39;eigenforces&#39;, &#39;coefficient&#39;, &#39;frequency&#39;,</span>
<span class="sd">        &#39;attenuation&#39;, &#39;phase_velocity&#39;.</span>
<span class="sd">        The parameter value (omega or wavenumber) is repeated as many as times as the number of eigenvalues.</span>
<span class="sd">        If direction is specified (+1 or -1), eigenmodes traveling in the non-desired direction are filtered out. </span>
<span class="sd">        If pml_threshold is specified, eigenmodes such that pml_ratio&lt;pml_threshold are filtered out.</span>
<span class="sd">        If i is specified, then the function returns the results for the ith parameter only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">argout</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;phase_velocity&#39;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span> <span class="c1">#create the temporary attribute &#39;phase_velocity&#39;</span>
            <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span> <span class="c1">#ignore divide by zero message (denominator may sometimes vanish) </span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s2">&quot;omega&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phase_velocity</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#&quot;wavenumber&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phase_velocity</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">wavenumber</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">))]</span>
            <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">one_or_two_pi</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="k">if</span> <span class="n">arg</span><span class="o">==</span><span class="s1">&#39;frequency&#39;</span> <span class="k">else</span> <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arg</span><span class="o">==</span><span class="s2">&quot;omega&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s2">&quot;omega&quot;</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">egv</span><span class="p">)</span> <span class="k">for</span> <span class="n">egv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">index</span><span class="p">]])</span><span class="o">/</span><span class="n">one_or_two_pi</span>
            <span class="k">elif</span> <span class="n">arg</span><span class="o">==</span><span class="s2">&quot;wavenumber&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s2">&quot;wavenumber&quot;</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavenumber</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">egv</span><span class="p">)</span> <span class="k">for</span> <span class="n">egv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">index</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="n">arg</span><span class="o">==</span><span class="s2">&quot;attenuation&quot;</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;eigenvalues&quot;</span><span class="p">)[</span><span class="n">index</span><span class="p">])</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">elif</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="o">==</span><span class="s2">&quot;wavenumber&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s2">&quot;omega&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">arg</span><span class="o">==</span><span class="s2">&quot;omega&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_type</span><span class="o">==</span><span class="s2">&quot;wavenumber&quot;</span><span class="p">):</span>
                    <span class="n">arg</span> <span class="o">=</span> <span class="s2">&quot;eigenvalues&quot;</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s1"> has not been computed: please compute it before plotting&#39;</span><span class="p">)</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)[</span><span class="n">index</span><span class="p">])</span><span class="o">/</span><span class="n">one_or_two_pi</span>
            <span class="n">argout</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> 
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traveling_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">imode</span> <span class="o">=</span> <span class="n">traveling_direction</span><span class="o">==</span><span class="n">direction</span> <span class="c1">#indices of modes traveling in the desired direction</span>
            <span class="n">argout</span> <span class="o">=</span> <span class="p">[</span><span class="n">argout</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">imode</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argout</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">argout</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">imode</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pml_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pml_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pml_ratio</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">iphysical</span> <span class="o">=</span> <span class="n">pml_ratio</span><span class="p">[</span><span class="n">imode</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">pml_threshold</span> <span class="c1">#indices of physical modes (i.e. excluding PML modes)</span>
            <span class="n">argout</span> <span class="o">=</span> <span class="p">[</span><span class="n">argout</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">iphysical</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argout</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">argout</span><span class="p">))]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argout</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">argout</span> <span class="o">=</span> <span class="n">argout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;phase_velocity&#39;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span> <span class="c1">#delete the attribute &#39;phase_velocity&#39;</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_velocity</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">argout</span>

    <span class="k">def</span> <span class="nf">_compute_if_necessary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">pml_threshold</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute traveling direction and pml ratio if necessary before plot (for internal use) &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traveling_direction</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>  <span class="c1">#compute the traveling direction if not yet computed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_traveling_direction</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pml_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pml_ratio</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>  <span class="c1">#compute the pml_ratio if not yet computed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_pml_ratio</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the PETSc diagonal matrix with diagonal entries given by vector vec (for internal use)&quot;&quot;&quot;</span>
        <span class="n">diag</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">createAIJ</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">nnz</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">diag</span><span class="o">.</span><span class="n">setUp</span><span class="p">()</span>
        <span class="n">diag</span><span class="o">.</span><span class="n">setDiagonal</span><span class="p">(</span><span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span><span class="o">.</span><span class="n">createWithArray</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">))</span>
        <span class="n">diag</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">diag</span>

    <span class="k">def</span> <span class="nf">_dot_eigenvectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">eigenfield</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dot product, mode by mode, between eigenvectors[i] (taking their conjugate) and a given</span>
<span class="sd">        eigenfield (for internal use).</span>
<span class="sd">        The matrix eigenfield must have the same size as eigenvectors[i]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getSize</span><span class="p">()[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eigenfield</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColumnVector</span><span class="p">(</span><span class="n">mode</span><span class="p">)))</span> <span class="c1">#dot: conjugate, tDot: without</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_build_block_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the block matrix [[A, B], [C, D]] given the equal-sized blocks A, B, C, D (for internal use) &quot;&quot;&quot;</span>    
        <span class="n">bs</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getSize</span><span class="p">()</span> <span class="c1">#block size</span>
        <span class="c1">#Block A</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getValuesCSR</span><span class="p">()</span>
        <span class="n">Mat</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">createAIJWithArrays</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">bs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">bs</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">csr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">csr</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">bs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">csr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">csr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">csr</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
        <span class="c1">#Block B</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">getValuesCSR</span><span class="p">()</span>
        <span class="n">Mat</span> <span class="o">=</span> <span class="n">Mat</span> <span class="o">+</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">createAIJWithArrays</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">bs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">bs</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">csr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">csr</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">bs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">csr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">csr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">bs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">csr</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
        <span class="c1">#Block C</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">getValuesCSR</span><span class="p">()</span>
        <span class="n">Mat</span> <span class="o">=</span> <span class="n">Mat</span> <span class="o">+</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">createAIJWithArrays</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">bs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">bs</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">csr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bs</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">csr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">csr</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
        <span class="c1">#Block D</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">getValuesCSR</span><span class="p">()</span>
        <span class="n">Mat</span> <span class="o">=</span> <span class="n">Mat</span> <span class="o">+</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">createAIJWithArrays</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">bs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">bs</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">csr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bs</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">csr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">bs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">csr</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Mat</span></div>


<div class="viewcode-block" id="Signal"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Signal">[docs]</a><span class="k">class</span> <span class="nc">Signal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for handling signals in the time domain and in the frequency domain</span>
<span class="sd">    </span>
<span class="sd">    Reminder:</span>
<span class="sd">    </span>
<span class="sd">    - the sampling frequency fs must be at least twice the highest excited frequency (fs&gt;=2fmax)</span>
<span class="sd">    - the time duration T must be large enough to capture the slowest wave at z, the source-receiver distance</span>
<span class="sd">    </span>
<span class="sd">    Fourier transform definition used: X(f) = 2/T * integral of x(t)*exp(+i*omega*t)*dt</span>
<span class="sd">    </span>
<span class="sd">    Two remarks:</span>
<span class="sd">    </span>
<span class="sd">    1. this is not the numpy fft function convention, which is in exp(-i*omega*t)</span>
<span class="sd">    2. the true amplitude of the Fourier transform, when needed, has to be obtained by</span>
<span class="sd">       multiplying the output (spectrum) by the scalar T/2, where T is the duration of the time signal</span>
<span class="sd">       (with the above definition: the division by T simplifies dimensionless analyses,</span>
<span class="sd">       and the factor 2 is used because only the positive part of the spectrum is considered)</span>
<span class="sd">    </span>
<span class="sd">    Complex Fourier transform:</span>
<span class="sd">    </span>
<span class="sd">    A complex Fourier transform is applied if alpha is set to a nonzero value.</span>
<span class="sd">    The frequency vector has then an imaginary part, constant and equal to alpha/(2*pi).</span>
<span class="sd">    Complex frequency computations can be useful for the analysis of long time duration signals (avoids aliasing).</span>
<span class="sd">    A good choice is alpha = log(50)/T.</span>
<span class="sd">    Note that the first frequency component is kept in that case (the frequency has a zero real part</span>
<span class="sd">    but non-zero imaginary part).</span>
<span class="sd">    </span>
<span class="sd">    Example::</span>
<span class="sd">    </span>
<span class="sd">        mysignal = Signal(alpha=0*np.log(50)/5e-4)</span>
<span class="sd">        mysignal.toneburst(fs=5000e3, T=5e-4, fc=100e3, n=5)</span>
<span class="sd">        mysignal.plot()</span>
<span class="sd">        mysignal.fft()</span>
<span class="sd">        mysignal.plot_spectrum()</span>
<span class="sd">        mysignal.ifft(coeff=1)</span>
<span class="sd">        mysignal.plot()</span>
<span class="sd">        plt.show()</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    time : numpy 1d array</span>
<span class="sd">        time vector</span>
<span class="sd">    waveform : numpy nd array</span>
<span class="sd">        waveform vectors stacked as rows (waveform is an array of size number_of_signals*len(time))</span>
<span class="sd">    frequency : numpy 1d array</span>
<span class="sd">        frequency vector</span>
<span class="sd">    spectrum : numpy nd array</span>
<span class="sd">        spectrum vectors stacked as rows (spectrum is an array of size number_of_signals*len(frequency))</span>
<span class="sd">    alpha : float</span>
<span class="sd">        decaying parameter to apply complex Fourier transform (useful for long time duration signal)</span>
<span class="sd">    </span>
<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __init__(time=None, waveform=None, frequency=None, spectrum=None, alpha=0):</span>
<span class="sd">        Constructor, initialization of signal (specify either waveform vs. time or spectrum vs. frequency)</span>
<span class="sd">    fft():</span>
<span class="sd">        Compute Fourier transform, results are stored as attributes (names: frequency, spectrum) </span>
<span class="sd">    ifft(coeff=1):</span>
<span class="sd">        Compute inverse Fourier transform, results are stored as attributes (names: time, waveform)</span>
<span class="sd">    ricker(fs, T, fc):</span>
<span class="sd">        Generate a Ricker signal</span>
<span class="sd">    toneburst(fs, T, fc, n):</span>
<span class="sd">        Generate a toneburst signal</span>
<span class="sd">    chirp(fs, T, f0, f1, chirp_duration):</span>
<span class="sd">        Generate a chirp signal</span>
<span class="sd">    plot(ax=None, color=&quot;k&quot;, linewidth=1, linestyle=&quot;-&quot;, **kwargs):</span>
<span class="sd">        Plot time waveform (waveform vs. time)</span>
<span class="sd">    plot_spectrum(ax=None, color=&quot;k&quot;, linewidth=1, linestyle=&quot;-&quot;, **kwargs):</span>
<span class="sd">        Plot the spectrum (spectrum vs. frequency), in magnitude and phase</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">waveform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : numpy 1d array</span>
<span class="sd">            time vector</span>
<span class="sd">        waveform : numpy array (1d or 2d)</span>
<span class="sd">            amplitude of signals in the time domain</span>
<span class="sd">        frequency : numpy 1d array</span>
<span class="sd">            frequency vector</span>
<span class="sd">        spectrum : numpy array (1d or 2d)</span>
<span class="sd">            amplitude of signals in the frequency domain</span>
<span class="sd">        alpha : float</span>
<span class="sd">            decaying parameter to apply complex Fourier transform (useful for long time duration signal)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span> <span class="o">=</span> <span class="n">waveform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="n">frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">spectrum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">waveform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Please specify both time and waveform&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">frequency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">spectrum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Please specify both frequency and spectrum&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Signal.fft"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Signal.fft">[docs]</a>    <span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Fourier transform (positive frequency part only, time waveform are assumed to be real).</span>
<span class="sd">        If the number of time steps is odd, one point is added.</span>
<span class="sd">        The zero frequency, if any, is suppressed.</span>
<span class="sd">        Results are stored as attributes (names: frequency, spectrum).</span>
<span class="sd">        spectrum is an array of size number_of_signals*len(frequency)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check waveform</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Time waveform is missing&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1">#if the number of points is odd, complete with one point</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;One point added in order to have length of t even&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveform</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">waveform</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1">#complete with one zero</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveform</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">temp</span><span class="o">-</span><span class="n">dt</span><span class="p">))</span><span class="o">/</span><span class="n">dt</span> <span class="o">&gt;=</span> <span class="mf">1e-3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Time steps might be unequally spaced! Please check&quot;</span><span class="p">)</span>
        
        <span class="c1"># FFT of excitation (the time signal x is multiplied by exp(-alpha*t) for complex Fourier transform)</span>
        <span class="c1">#T = self.time[-1] #time duration</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span> <span class="c1">#sampling frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveform</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">/</span> <span class="n">N</span>  <span class="c1">#conj() because our convention is +i*omega*t, as opposed to fft function</span>
        <span class="n">Np</span> <span class="o">=</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span>  <span class="c1">#number of points of the positive part of the spectrum (N is even)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Np</span><span class="p">)</span>  <span class="c1">#frequency vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1">#complex frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Np</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>  <span class="c1">#suppress first frequency if zero</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signal.ifft"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Signal.ifft">[docs]</a>    <span class="k">def</span> <span class="nf">ifft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute inverse Fourier transform (only the positive frequency part is needed, time waveform are assumed to be real).</span>
<span class="sd">        Zero padding is applied in the low-frequency range (if missing) and in the high-frequency range (if coeff is greater than 1).</span>
<span class="sd">        Zero padding in the high frequency range is applied up to the frequency coeff*max(frequency).</span>
<span class="sd">        Results are stored as attributes (names: time, waveform).</span>
<span class="sd">        waveform is an array of size number_of_signals*len(time).</span>
<span class="sd">        &quot;&quot;&quot;</span>    
        <span class="c1"># Check spectrum</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Frequency spectrum is missing&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The imaginary part of the frequency vector must remain constant&#39;</span><span class="p">)</span>
        
        <span class="c1"># Zero padding in low and high frequencies</span>
        <span class="n">frequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">frequency</span><span class="p">))</span>  <span class="c1">#frequency step</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">frequency</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="o">*</span><span class="n">df</span><span class="p">:</span>  <span class="c1">#the first frequency is zero</span>
            <span class="n">frequency</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">f_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1">#non-zero first frequency</span>
            <span class="n">f_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frequency</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">1e-6</span><span class="o">*</span><span class="n">df</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>  <span class="c1">#low frequency</span>
        <span class="n">f_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">frequency</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">df</span><span class="p">,</span> <span class="n">coeff</span><span class="o">*</span><span class="n">frequency</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">1e-6</span><span class="o">*</span><span class="n">df</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>  <span class="c1">#high frequency</span>
        <span class="n">frequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">f_low</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">f_high</span><span class="p">])</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency</span><span class="p">))</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_low</span><span class="p">))),</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_high</span><span class="p">)))],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_low</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Zero padding applied in the missing low-frequency range&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_high</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Zero padding applied in the high-frequency range&#39;</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">temp</span><span class="o">-</span><span class="n">df</span><span class="p">))</span><span class="o">/</span><span class="n">df</span> <span class="o">&gt;=</span> <span class="mf">1e-3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Frequency steps might be unequally spaced! Please check&#39;</span><span class="p">)</span>
        
        <span class="c1"># IFFT of response</span>
        <span class="n">Np</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1">#number of points of the spectrum (positive part of the spectrum)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Np</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1">#number of points for the IFFT</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">df</span><span class="p">)</span>  <span class="c1">#sample time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">Np</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span> <span class="c1">#for complex Fourier transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveform</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signal.ricker"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Signal.ricker">[docs]</a>    <span class="k">def</span> <span class="nf">ricker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">fc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a Ricker wavelet signal of unit amplitude (fs: sampling frequency, T: time duration, fc: Ricker central frequency)</span>
<span class="sd">        </span>
<span class="sd">        Note that for better accuracy:</span>
<span class="sd">        </span>
<span class="sd">        - fs is rounded so that fs/fc is an integer</span>
<span class="sd">        - T is adjusted so that the number of points is even</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Time</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="n">fc</span><span class="p">)</span><span class="o">*</span><span class="n">fc</span>  <span class="c1">#redefine fs so that fs/fc is an integer</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span>  <span class="c1">#time step</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span> <span class="o">+</span> <span class="n">dt</span>  <span class="c1">#redefine T so that the number of points is equal to an even integer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mf">1e-6</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1">#time vector</span>
        <span class="c1">#N = len(self.time)  # number of points (N=T/dt+1, even)</span>
        
        <span class="c1"># Ricker waveform</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">fc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">fc</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">fc</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span></div>

<div class="viewcode-block" id="Signal.toneburst"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Signal.toneburst">[docs]</a>    <span class="k">def</span> <span class="nf">toneburst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a toneburst signal (fs: sampling frequency, T: time duration, fc: central frequency, n: number of cycles).</span>
<span class="sd">        This signal is a Hanning-modulated n cycles sinusoidal toneburst centred at fc Hz (with unit amplitude).</span>
<span class="sd">        For this kind of excitation, fmax can be considered as 2*fc roughly, hence one should choose fs&gt;=4fc.</span>
<span class="sd">        </span>
<span class="sd">        Note that for better accuracy:</span>
<span class="sd">        </span>
<span class="sd">        - fs is rounded so that fs/fc is an integer</span>
<span class="sd">        - T is adjusted so that the number of points is even</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Time</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="n">fc</span><span class="p">)</span><span class="o">*</span><span class="n">fc</span>  <span class="c1">#redefine fs so that fs/fc is an integer</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span>  <span class="c1">#time step</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span> <span class="o">+</span> <span class="n">dt</span>  <span class="c1">#redefine T so that the number of points is equal to an even integer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mf">1e-6</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1">#time vector</span>
        <span class="c1">#N = len(self.time)  # number of points (N=T/dt+1, even)</span>
        
        <span class="c1"># Toneburst waveform</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">/</span><span class="n">fc</span><span class="o">+</span><span class="mf">1e-6</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1">#n/fc yields an integer number of time steps because fs/fc is an integer</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">fc</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c1">#hanning window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="n">x</span>  <span class="c1">#time amplitude vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span></div>

<div class="viewcode-block" id="Signal.chirp"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Signal.chirp">[docs]</a>    <span class="k">def</span> <span class="nf">chirp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">chirp_duration</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a chirp of unit amplitude (fs: sampling frequency, T: time duration, f0: first frequency, f1: last frequency, chirp_duration: time to sweep from f0 to f1).</span>
<span class="sd">        Note that for better accuracy, T is adjusted so that the number of points is even.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Time</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span>  <span class="c1">#time step</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span> <span class="o">+</span> <span class="n">dt</span>  <span class="c1">#redefine T so that the number of points is equal to an even integer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mf">1e-6</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1">#time vector</span>
        
        <span class="c1"># Chirp waveform</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">-</span><span class="n">chirp_duration</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f0</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">f1</span><span class="o">-</span><span class="n">f0</span><span class="p">)</span><span class="o">/</span><span class="n">chirp_duration</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="n">x</span>  <span class="c1">#time amplitude vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span></div>

<div class="viewcode-block" id="Signal.plot"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Signal.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot time waveform (waveform vs. time)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax: matplotlib axis</span>
<span class="sd">            the matplotlib axis on which to plot data (created if None)</span>
<span class="sd">        color: str, linewidth: int, linestyle: str, **kwargs are passed to ax.plot</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ll: the matplotlib list of lines</span>
<span class="sd">        &quot;&quot;&quot;</span>                                                     
        <span class="c1"># Initialization</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Plot waveform vs. time</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveform</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ll</span></div>

<div class="viewcode-block" id="Signal.plot_spectrum"><a class="viewcode-back" href="../../waveguicsx.html#waveguicsx.waveguide.Signal.plot_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">plot_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the spectrum (spectrum vs. frequency), in magnitude and phase</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax: matplotlib axis</span>
<span class="sd">            the matplotlib axis on which to plot data (created if None)</span>
<span class="sd">        color: str, linewidth: int, linestyle: str, **kwargs are passed to ax.plot</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ll_abs: the matplotlib list of lines for magnitude plot</span>
<span class="sd">        ll_angle: same but for phase plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialization</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Plot spectrum magnitude vs. frequency</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ll_abs</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;|X|&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="c1"># Plot spectrum phase vs. frequency</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ll_angle</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;arg(X)&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ll_abs</span><span class="p">,</span> <span class="n">ll_angle</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2024, Fabien Treyssede.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>