<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Presentation &mdash; waveguicsx 2.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Documentation" href="documentation.html" />
    <link rel="prev" title="Waveguicsx - Version 2.1" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/logo_doc.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Presentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">0. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-examples">1. Basic examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#prerequisites">2. Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="#installation">3. Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#documentation">4. Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tutorials">5. Tutorials</a></li>
<li class="toctree-l2"><a class="reference internal" href="#scattering-by-local-inhomogeneities">6. Scattering by local inhomogeneities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#authors-and-contributors">7. Authors and contributors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-cite">8. How to cite</a></li>
<li class="toctree-l2"><a class="reference internal" href="#license">9. License</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="waveguicsx.html">waveguide.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="waveguicsx.html#module-waveguicsx.scattering">scattering.py</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#three-dimensional-elastic-bar-of-square-cross-section">0. Three-dimensional elastic bar of square cross-section</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#three-dimensional-elastic-bar-of-square-cross-section-with-parallelization">1. Three-dimensional elastic bar of square cross-section with parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#three-dimensional-elastic-bar-of-square-cross-section-buried-into-a-pml-external-medium">2. Three-dimensional elastic bar of square cross-section buried into a PML external medium</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#three-dimensional-elastic-bar-of-square-cross-section-buried-into-a-pml-external-medium-using-gmsh">3. Three-dimensional elastic bar of square cross-section buried into a PML external medium using gmsh</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#excitation-of-a-three-dimensional-elastic-bar-of-circular-cross-section">4. Excitation of a three-dimensional elastic bar of circular cross-section</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#excitation-of-a-three-dimensional-elastic-bar-of-circular-cross-section-with-parallelization">5. Excitation of a three-dimensional elastic bar of circular cross-section with parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#time-response-of-a-two-dimensional-plate-excited-near-its-first-zgv-resonance">6. Time response of a two-dimensional plate excited near its first ZGV resonance</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#dispersion-curves-of-a-rail">7. Dispersion curves of a rail</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#reflection-of-lamb-modes-by-the-free-edge-of-a-plate">8. Reflection of Lamb modes by the free edge of a plate</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#reflection-and-transmission-of-pochhammer-chree-modes-inside-a-cylinder">9. Reflection and transmission of Pochhammer-Chree modes inside a cylinder</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">waveguicsx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">Presentation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/readme_link.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="presentation">
<h1>Presentation<a class="headerlink" href="#presentation" title="Permalink to this heading"></a></h1>
<p><a class="reference external" href="https://universite-gustave-eiffel.github.io/waveguicsx/"><img alt="Generic badge" src="https://github.com/Universite-Gustave-Eiffel/waveguicsx/actions/workflows/pages/pages-build-deployment/badge.svg" /></a></p>
<p><strong>Waveguicsx, a python library for solving complex waveguide problems</strong></p>
<p><strong>Copyright (C) 2023-2024  Fabien Treyssede</strong></p>
<p>This file is part of waveguicsx.</p>
<p>waveguicsx is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>waveguicsx is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with waveguicsx. If not, see <a class="reference external" href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.</p>
<p>Contact: fabien.treyssede&#64;univ-eiffel.fr</p>
<section id="introduction">
<h2>0. Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>Waveguicsx is a python library for solving complex waveguide problems based on SLEPc eigensolver.</p>
<p>Waveguicsx is freely available under the GNU GPL, version 3, thus providing an accessible solution to the scientific community. Waveguicsx stems from expertise gained over the past 15 years through the guided wave research activity of the GeoEND team at Université Gustave Eiffel in the fields of non-destructive evaluation and geophysics.</p>
<p>The full documentation is entirely defined in the `waveguide.py’ module. See also https://universite-gustave-eiffel.github.io/waveguicsx.</p>
<p>Waveguicsx can deal with complex elastic waveguides, two-dimensional (e.g. plates) or three-dimensional (arbitrarily shaped cross-section), inhomogeneous in the transverse directions, anisotropic. Complex-valued problems can be handled including the effects of non-propagating modes (evanescent, inhomogeneous), viscoelastic loss (complex material properties) or perfectly matched layers (PML) to simulate buried waveguides.</p>
<p>More precisely, waveguicsx solves the following matrix problem: <span class="math notranslate nohighlight">\((\textbf{K}_0-\omega^2\textbf{M}+\text{i}k(\textbf{K}_1+\textbf{K}_1^\text{T})+k^2\textbf{K}_2)\textbf{U}=\textbf{F}\)</span>. This kind of problem typically stems from the so-called semi-analytical finite element (FE) method. See references below for theoretical details.</p>
<p>The inputs of waveguicsx are: the matrices <span class="math notranslate nohighlight">\(\textbf{K}_0\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_1\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_2\)</span>, <span class="math notranslate nohighlight">\(\textbf{M}\)</span> (PETSc matrix format) to compute the free response of waveguide (dispersion curves), as well as the excitation vector <span class="math notranslate nohighlight">\(\textbf{F}\)</span> if computing forced response is required. These matrices can be built from your own favorite code. In this case, you just need to import these matrices to Python and converted them to PETSc format (see basic examples below). In case you do not have any code to generate these matrices, you can use the open finite element software FEniCSX (installation required) as shown in the tutorials.</p>
<p>The free response (<span class="math notranslate nohighlight">\(\textbf{F}=\textbf{0}\)</span>) corresponds an eigenvalue problem, solved iteratively by varying the angular frequency <span class="math notranslate nohighlight">\(\omega\)</span>, or alternatively, the wavenumber <span class="math notranslate nohighlight">\(k\)</span>, leading to dispersion curve results. In the former case, the eigenvalue is <span class="math notranslate nohighlight">\(k\)</span>, while in the latter case, the eigenvalue is <span class="math notranslate nohighlight">\(\omega^2\)</span>. The loops over the parameter (angular frequency or wavenumber) can be parallelized, as shown in some tutorials (using mpi4py). Various modal properties (energy velocity, group velocity, excitability…) can be post-processed as a function of the frequency and plotted as dispersion curves.</p>
<p>The forced reponse (<span class="math notranslate nohighlight">\(\textbf{F}\neq\textbf{0}\)</span>) is solved in the frequency domain by expanding the solution as a sum of eigenmodes using biorthogonality relationship, leading to very fast computations of the excited wavefields. The transient response can finally be processed in the time domain by inverse FFT.</p>
<p>The library contains two classes. The main class, the class Waveguide, enables to solve the waveguide problem defined by the following inputs: <span class="math notranslate nohighlight">\(\textbf{K}_0\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_1\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_2\)</span>, <span class="math notranslate nohighlight">\(\textbf{M}\)</span> and <span class="math notranslate nohighlight">\(\textbf{F}\)</span>. The other class, the class Signal, is provided to easily handle the transforms of signals from frequency to time and inversely, as well as the generation of excitation pulses.</p>
<p>Waveguicsx can also solve scattering problems by local inhomogeneities based on transparent boundary conditions (so-called hybrid FE-SAFE method), please see the dedicated section below.</p>
</section>
<section id="basic-examples">
<h2>1. Basic examples<a class="headerlink" href="#basic-examples" title="Permalink to this heading"></a></h2>
<p><strong>Basic example 1: dispersion curves of a homogeneous plate</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">###########################################</span>
<span class="c1"># Basic example 1: dispersion curves of a homogeneous plate</span>
<span class="c1">#</span>
<span class="c1"># Important note:\</span>
<span class="c1"># This basic example uses previously built PETSc matrices stored into a binary file.\</span>
<span class="c1"># If you want to use your own matrices, you have to convert them to PETSc format. Examples of conversion are given below.\</span>
<span class="c1"># ** Conversion of a 2d numpy array M to PETSc (dense matrix): **\</span>
<span class="c1"># M = PETSc.Mat().createDense(M.shape, array=M)\</span>
<span class="c1"># ** Importing sparse matrix M from Matlab to scipy (sparse matrix): **\</span>
<span class="c1"># matrices = scipy.io.loadmat(&#39;matlab_file.mat&#39;) #here, the Matlab file &#39;matlab_file.mat&#39; is supposed to contain the variable M (Matlab sparse matrix)\</span>
<span class="c1"># M = matrices[&#39;M&#39;] #&#39;M&#39; is the name of the Matlab variable\</span>
<span class="c1"># ** Conversion of a scipy sparse matrix M to PETSc: **\</span>
<span class="c1"># M = M.tocsr() #convert to csr format first\</span>
<span class="c1"># M = PETSc.Mat().createAIJ(size=M.shape, csr=(M.indptr, M.indices, M.data))</span>

<span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="kn">from</span> <span class="nn">petsc4py</span> <span class="kn">import</span> <span class="n">PETSc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">waveguicsx.waveguide</span> <span class="kn">import</span> <span class="n">Waveguide</span>

<span class="c1">###########################################</span>
<span class="c1"># Load PETSc matrices, K0, K1, K2 and M saved into the binary file &#39;BasicExample.dat&#39;.\</span>
<span class="c1"># This file contains matrices for a homogeneous plate of thickness 1 and Poisson ratio 0.3.\</span>
<span class="c1"># It can be found in the subfolder &#39;examples&#39;\</span>
<span class="c1"># (file generated from the tutorial &#39;Elastic_Waveguide_Plate2D_TransientResponse.py&#39;)</span>
<span class="n">viewer</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Viewer</span><span class="p">()</span><span class="o">.</span><span class="n">createBinary</span><span class="p">(</span><span class="s1">&#39;BasicExample.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="c1">#note: calls below must be in order that objects have been stored</span>
<span class="n">K0</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">K1</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">K2</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>

<span class="c1">###########################################</span>
<span class="c1"># Initialization of waveguide</span>
<span class="n">wg</span> <span class="o">=</span> <span class="n">Waveguide</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span> <span class="c1">#set the parameter range (here, normalized angular frequency)</span>
<span class="c1">#wg.set_parameters(wavenumber=np.arange(0.1, 10.1, 0.1)) #uncomment this line if the parameter is the wavenumber instead of the angular frequency (reduce also nev)</span>

<span class="c1">###########################################</span>
<span class="c1"># Solution of eigenvalue problem (iteration over parameter)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nev</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#access to eigensolutions with: wg.eigenvalues[iomega][imode], wg.eigenvectors[iomega][idof,imode]</span>
<span class="n">wg</span><span class="o">.</span><span class="n">compute_energy_velocity</span><span class="p">()</span> <span class="c1">#post-process energy velocity</span>

<span class="c1">###########################################</span>
<span class="c1"># Plot dispersion curves (by default, normalized)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1">#normalized angular frequency vs. normalized wavenumber</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot_energy_velocity</span><span class="p">()</span> <span class="c1">#normalized energy velocity vs. normalized angular frequency</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1">###########################################</span>
<span class="c1"># Example of dimensional plots</span>
<span class="n">h</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">3260</span><span class="p">,</span> <span class="mi">7800</span> <span class="c1">#plate thickness (m), shear wave celerity (m/s), density (kg/m**3)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">set_plot_scaler</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">h</span><span class="o">/</span><span class="n">cs</span><span class="p">,</span> <span class="n">mass</span><span class="o">=</span><span class="n">rho</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#set characteristic length, time and mass</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1">#frequency (Hz) vs. wavenumber (1/m)</span>
<span class="c1">#wg.plot_energy_velocity() #energy velocity (m/s) vs. frequency (Hz)</span>
<span class="c1"># Energy velocity plot with user-defined units (here, m/ms vs. MHz-mm)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="s2">&quot;energy_velocity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="o">/</span><span class="mi">1000</span> <span class="c1">#units in m/ms</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="s2">&quot;frequency&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="o">/</span><span class="mi">1000</span> <span class="c1">#frequency units in MHz-mm</span>
<span class="n">sc</span> <span class="o">=</span> <span class="n">wg</span><span class="o">.</span><span class="n">plot_energy_velocity</span><span class="p">(</span><span class="n">direction</span><span class="o">=+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#plot positive-going modes</span>
<span class="n">sc</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency-thickness (MHz-mm)&#39;</span><span class="p">)</span>
<span class="n">sc</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Energy velocity (m/ms)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Basic example 2: forced response of a homogeneous plate</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">###########################################</span>
<span class="c1"># Basic example 2: forced response of a homogeneous plate</span>
<span class="c1">#</span>
<span class="c1"># Important note:\</span>
<span class="c1"># This basic example uses previously built PETSc matrices stored into a binary file.\</span>
<span class="c1"># If you want to use your own matrices, you have to convert them to PETSc format. Examples of conversion are given below.\</span>
<span class="c1"># ** Conversion of a 2d numpy array M to PETSc (dense matrix): **\</span>
<span class="c1"># M = PETSc.Mat().createDense(M.shape, array=M)\</span>
<span class="c1"># ** Importing sparse matrix M from Matlab to scipy (sparse matrix): **\</span>
<span class="c1"># matrices = scipy.io.loadmat(&#39;matlab_file.mat&#39;) #here, the Matlab file &#39;matlab_file.mat&#39; is supposed to contain the variable M (Matlab sparse matrix)\</span>
<span class="c1"># M = matrices[&#39;M&#39;] #&#39;M&#39; is the name of the Matlab variable\</span>
<span class="c1"># ** Conversion of a scipy sparse matrix M to PETSc: **\</span>
<span class="c1"># M = M.tocsr() #convert to csr format first\</span>
<span class="c1"># M = PETSc.Mat().createAIJ(size=M.shape, csr=(M.indptr, M.indices, M.data))</span>

<span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="kn">from</span> <span class="nn">petsc4py</span> <span class="kn">import</span> <span class="n">PETSc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">waveguicsx.waveguide</span> <span class="kn">import</span> <span class="n">Waveguide</span><span class="p">,</span> <span class="n">Signal</span>

<span class="c1">###########################################</span>
<span class="c1"># Load PETSc matrices, K0, K1, K2 and M, as well as PETSc vector F, saved into the binary file &#39;BasicExample.dat&#39;.\</span>
<span class="c1"># This file contains matrices for a homogeneous plate of thickness 1 and Poisson ratio 0.3.\</span>
<span class="c1"># It can be found in the subfolder &#39;examples&#39;\</span>
<span class="c1"># (file generated from the tutorial &#39;Elastic_Waveguide_Plate2D_TransientResponse.py&#39;)</span>
<span class="n">viewer</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Viewer</span><span class="p">()</span><span class="o">.</span><span class="n">createBinary</span><span class="p">(</span><span class="s1">&#39;BasicExample.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="c1">#note: calls below must be in order that objects have been stored</span>
<span class="n">K0</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">K1</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">K2</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>

<span class="c1">###########################################</span>
<span class="c1"># Input parameters</span>
<span class="n">h</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">cs</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">7800</span><span class="p">,</span> <span class="mi">3218</span> <span class="c1">#plate thickness (m), density (kg/m3), shear wave celerity (m/s)</span>
<span class="n">nev</span> <span class="o">=</span> <span class="mi">20</span> <span class="c1">#number of eigenvalues requested at each frequency</span>

<span class="c1">###########################################</span>
<span class="c1"># Excitation spectrum (toneburst)</span>
<span class="n">excitation</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">()</span>
<span class="n">excitation</span><span class="o">.</span><span class="n">toneburst</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="mf">400e3</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">2e-3</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="mf">100e3</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="c1">#central frequency 100 kHz, 8 cycles, duration 2 ms</span>
<span class="n">excitation</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">excitation</span><span class="o">.</span><span class="n">plot_spectrum</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">excitation</span><span class="o">.</span><span class="n">frequency</span> <span class="c1">#angular frequency range (rad/s)</span>
<span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="n">cs</span> <span class="c1">#normalize angular frequency, because PETSC matrices have been generated for a plate of thickness 1</span>

<span class="c1">###########################################</span>
<span class="c1"># Initialization of waveguide</span>
<span class="n">wg</span> <span class="o">=</span> <span class="n">Waveguide</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span> <span class="c1">#set the parameter range (here, normalized angular frequency)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">set_plot_scaler</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">h</span><span class="o">/</span><span class="n">cs</span><span class="p">,</span> <span class="n">mass</span><span class="o">=</span><span class="n">rho</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#uncomment this line if you want to plot dimensional results, otherwise comment for normalized results</span>

<span class="c1">###########################################</span>
<span class="c1"># Free response (dispersion curves)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nev</span><span class="o">=</span><span class="n">nev</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#solution of eigenvalue problem (iteration over parameter)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">compute_group_velocity</span><span class="p">()</span> <span class="c1">#post-process group velocity</span>

<span class="c1">###########################################</span>
<span class="c1"># Computation of modal coefficients due to excitation vector F</span>
<span class="c1"># and modal excitabilities at degree of freedom dof</span>
<span class="c1"># F is a unit point force applied normally to the bottom surface of the plate</span>
<span class="n">wg</span><span class="o">.</span><span class="n">compute_response_coefficient</span><span class="p">(</span><span class="n">F</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="mi">38</span><span class="p">)</span> <span class="c1">#here, dof index 38 is x-component (i.e. normal to the plate) at x=1 (i.e. top of the plate)</span>
<span class="n">sc</span> <span class="o">=</span> <span class="n">wg</span><span class="o">.</span><span class="n">plot_energy_velocity</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;excitability&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">],</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span> <span class="c1">#plot the energy velocity colored by the excitability modulus</span>
<span class="n">sc</span><span class="o">.</span><span class="n">colorbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;excitability&#39;</span><span class="p">)</span>
<span class="c1">#sc.axes.set_ylim([0, 2*cs]) #set y limits if necessary</span>
<span class="c1">#sc.set_clim([1e-14,1e-11]) #set colorbar limits if necessary</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1">###########################################</span>
<span class="c1"># Forced response at degree of freedom dof and axial coordinates z (z is normalized by h)</span>
<span class="n">frequency</span><span class="p">,</span> <span class="n">response</span> <span class="o">=</span> <span class="n">wg</span><span class="o">.</span><span class="n">compute_response</span><span class="p">(</span><span class="n">dof</span><span class="o">=</span><span class="mi">38</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="n">spectrum</span><span class="o">=</span><span class="n">excitation</span><span class="o">.</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1">#response in the frequency domain at z/h=50</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">frequency</span><span class="o">=</span><span class="n">frequency</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">=</span><span class="n">response</span><span class="p">)</span>
<span class="n">response</span><span class="o">.</span><span class="n">plot_spectrum</span><span class="p">()</span>
<span class="n">response</span><span class="o">.</span><span class="n">ifft</span><span class="p">()</span>
<span class="n">response</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="prerequisites">
<h2>2. Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this heading"></a></h2>
<p>Waveguicsx requires the complex version of SLEPc and PETSc (slepc4py, petsc4py).</p>
<p>The necessary inputs to waveguicsx are the matrices <span class="math notranslate nohighlight">\(\textbf{K}_0\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_1\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_2\)</span>, <span class="math notranslate nohighlight">\(\textbf{M}\)</span> (PETSc matrix format) to compute the free response of waveguide (dispersion curves), as well as the vector <span class="math notranslate nohighlight">\(\textbf{F}\)</span> to compute the forced response. These matrices can be built from any code, then imported to Python and converted to PETSc format.</p>
<p><strong>Tutorials:</strong></p>
<p>In the tutorials (see subfolder ‘examples’), these matrices are built from the open finite element (FE) platform FEniCSX. To run these tutorials, you will therefore need to install FEniCSX first. Note that tutorials are py files formatted such that they can be conveniently opened in a text editor or in a jupyter notebook.</p>
<p><em>Tutorial files are currently written for FEniCSX v0.6.0, minor modifications may be required for use with latest versions (work under progress).</em></p>
</section>
<section id="installation">
<h2>3. Installation<a class="headerlink" href="#installation" title="Permalink to this heading"></a></h2>
<section id="clone-the-waveguicsx-public-repository">
<h3>3.1 Clone the Waveguicsx public repository<a class="headerlink" href="#clone-the-waveguicsx-public-repository" title="Permalink to this heading"></a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/Universite-Gustave-Eiffel/waveguicsx.git
<span class="nb">cd</span><span class="w"> </span>./waveguicsx
</pre></div>
</div>
</section>
<section id="generate-the-docker-image-and-run-the-container">
<h3>3.2 Generate the docker image and run the container<a class="headerlink" href="#generate-the-docker-image-and-run-the-container" title="Permalink to this heading"></a></h3>
<p>FEniCSX is not a dependency of waveguicsx. Nevertheless, it is required to run the tutorials.
We recommend using the docker image of DOLFINX/v0.6.0 sourced in complex mode before running the tutorials :</p>
<p>Install <a class="reference external" href="https://docs.docker.com/engine/install">Docker</a> and authorize <a class="reference external" href="https://docs.docker.com/engine/install/linux-postinstall/">non-root users</a>.</p>
<p>Then run the following shell script file of waveguicsx repository (launch docker container):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./launch_fenicsx.sh
</pre></div>
</div>
<p>The first run will install FEniCSX inside the container, which may take time.</p>
<p><em>Only the first time</em> : once the container is launched, install the waveguicsx package using:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>complex<span class="o">]</span>waveguicsxuser@hostname:~$<span class="w"> </span>python3<span class="w"> </span>-m<span class="w"> </span>pip<span class="w"> </span>install<span class="w"> </span>-e<span class="w"> </span>.
</pre></div>
</div>
<p><em>Warning</em> : the waveguicsx folder (i.e. <code class="docutils literal notranslate"><span class="pre">.</span></code>) is mounted inside the container in <code class="docutils literal notranslate"><span class="pre">/home/waveguicsxuser</span></code> :
so that all changes are persistent and modify the repository of the host system as well.<br />
The python package files will be installed in the <code class="docutils literal notranslate"><span class="pre">.local</span></code> folder (ignored by <code class="docutils literal notranslate"><span class="pre">git</span></code>),
so that it is not necessary to reinstall the package with pip each time the container is launched.</p>
<p>Once the container is launched, here are examples of usage inside the container :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>complex<span class="o">]</span>waveguicsxuser@hostname:~$<span class="w"> </span>python3<span class="w"> </span>./examples/BasicExample1.py<span class="w">  </span><span class="c1"># run a basic example (check that everything works)</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>complex<span class="o">]</span>waveguicsxuser@hostname:~$<span class="w"> </span>python3<span class="w"> </span>./examples/Elastic_Waveguide_SquareBar3D.py<span class="w">  </span><span class="c1"># run a tutorial in cli</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>complex<span class="o">]</span>waveguicsxuser@hostname:~$<span class="w"> </span>jupyter<span class="w"> </span>notebook<span class="w">  </span><span class="c1"># launch the jupyter notebook from inside the container</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>complex<span class="o">]</span>waveguicsxuser@hostname:~$<span class="w"> </span><span class="nb">exit</span><span class="w">  </span><span class="c1"># leave the container</span>
</pre></div>
</div>
</section>
</section>
<section id="documentation">
<h2>4. Documentation<a class="headerlink" href="#documentation" title="Permalink to this heading"></a></h2>
<p>The documentation is entirely defined in the `waveguide.py’ module.</p>
<p>You can also see the full documentation at: https://universite-gustave-eiffel.github.io/waveguicsx.</p>
<p>You can also build the documentation, using <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">doc</span></code> and opening the front page in <code class="docutils literal notranslate"><span class="pre">./doc/Waveguicsx_documentation.html</span></code>.</p>
</section>
<section id="tutorials">
<h2>5. Tutorials<a class="headerlink" href="#tutorials" title="Permalink to this heading"></a></h2>
<p>Various tutorials are provided in the subfolder ‘examples’. These tutorials fully depict simple as well as more complex problems, two-dimensional (plates) or three-dimensional (bars, rail…), including viscoelastic loss or perfectly matched layers (used for buried waveguides). In particular, these tutorials show how to build the finite element matrices <span class="math notranslate nohighlight">\(\textbf{K}_0\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_1\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_2\)</span>, <span class="math notranslate nohighlight">\(\textbf{M}\)</span> with FEniCSX. Installing FEniCSX is therefore required to run the tutorials.</p>
<p>In case you have your own code to generate these matrices, you can readily forget FEniCSX parts in each tutorial, and only consider the part dedicated to waveguicsx.</p>
</section>
<section id="scattering-by-local-inhomogeneities">
<h2>6. Scattering by local inhomogeneities<a class="headerlink" href="#scattering-by-local-inhomogeneities" title="Permalink to this heading"></a></h2>
<p>Waveguicsx can also solve scattering problems by local inhomogeneities based on transparent boundary conditions.</p>
<p>This has been implemented in the scattering.py module, defining a third class named Scattering. The full documentation is entirely defined in the scattering.py module.</p>
<p>The following matrix problem is considered: <span class="math notranslate nohighlight">\((\textbf{K}-\omega^2\textbf{M}-\text{i}\omega\textbf{C})\textbf{U}=\textbf{F}\)</span>. This kind of problem typically typically stems from a finite element (FE) model of a small portion of waveguide including a local inhomogeneity (e.g. defects). The cross-section extremities of the truncated FE model are then handled by transparent boundary conditions (BCs) to reproduce semi-infinite waveguides. Such an approach is sometimes called as hybrid FE-SAFE method (see references below for theoretical details). The so-obtained scattering problem is solved repeatedly for each frequency (using PETSc). The loops over the angular frequency can be parallelized, as shown in some tutorials (using mpi4py).</p>
<p>The user must supply the following inputs: the global FE matrices <span class="math notranslate nohighlight">\(\textbf{K}\)</span>, <span class="math notranslate nohighlight">\(\textbf{M}\)</span>, <span class="math notranslate nohighlight">\(\textbf{C}\)</span> (stiffness, mass and viscous damping), the global FE vector <span class="math notranslate nohighlight">\(\textbf{F}\)</span> (excitation inside the FE model) and the transparent BCs (localized by their degrees of freedom in the global vector U). Transparent BCs are Waveguide objects, which must have been solved prior to the scattering problem solution (see waveguide.py module).</p>
<p>For each angular frequency <span class="math notranslate nohighlight">\(\omega\)</span>, the solution to the scattering problem yields the displacement <span class="math notranslate nohighlight">\(\textbf{U}\)</span> of the FE model, as well as the outgoing modal coefficients of every transparent BC.</p>
<p>Note that the FE matrices can be built from any code (then imported to Python and converted to PETSc format). In the tutorials, these matrices are built from the open finite element (FE) platform FEniCSX (see subfolder ‘examples’).</p>
<p><strong>Basic scattering example: reflection of Lamb modes by the free edge of a plate</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">###########################################</span>
<span class="c1"># Basic scattering example: reflection of Lamb modes by the free edge of a plate\</span>
<span class="c1"># This simple example involves only one transparent boundary condition (the &quot;inlet&quot;),\</span>
<span class="c1"># supposed to be at the left-hand side of the FE box (negative outward normal)\</span>
<span class="c1">#</span>
<span class="c1"># Important note:\</span>
<span class="c1"># This basic example uses previously built PETSc matrices stored into a binary file.\</span>
<span class="c1"># If you want to use your own matrices, you have to convert them to PETSc format. Examples of conversion are given below.\</span>
<span class="c1"># ** Conversion of a 2d numpy array M to PETSc (dense matrix): **\</span>
<span class="c1"># M = PETSc.Mat().createDense(M.shape, array=M)\</span>
<span class="c1"># ** Importing sparse matrix M from Matlab to scipy (sparse matrix): **\</span>
<span class="c1"># matrices = scipy.io.loadmat(&#39;matlab_file.mat&#39;) #here, the Matlab file &#39;matlab_file.mat&#39; is supposed to contain the variable M (Matlab sparse matrix)\</span>
<span class="c1"># M = matrices[&#39;M&#39;] #&#39;M&#39; is the name of the Matlab variable\</span>
<span class="c1"># ** Conversion of a scipy sparse matrix M to PETSc: **\</span>
<span class="c1"># M = M.tocsr() #convert to csr format first\</span>
<span class="c1"># M = PETSc.Mat().createAIJ(size=M.shape, csr=(M.indptr, M.indices, M.data))</span>

<span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="kn">from</span> <span class="nn">petsc4py</span> <span class="kn">import</span> <span class="n">PETSc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">waveguicsx.waveguide</span> <span class="kn">import</span> <span class="n">Waveguide</span>
<span class="kn">from</span> <span class="nn">waveguicsx.scattering</span> <span class="kn">import</span> <span class="n">Scattering</span>

<span class="c1">###########################################</span>
<span class="c1"># Load PETSc matrices, M, K, Ms, K0, K1, K2 saved into the binary file &#39;BasicScatteringExample.dat&#39;.\</span>
<span class="c1"># This file contains matrices for the reflection of Lamb modes by the free edge of a homogeneous plate of thickness 1 and Poisson ratio 0.25.\</span>
<span class="c1"># It can be found in the subfolder &#39;examples&#39;\</span>
<span class="c1"># (file generated from the tutorial &#39;Scattering_Elastic_Waveguide_Plate2D_Gmsh.py&#39;)</span>
<span class="n">viewer</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Viewer</span><span class="p">()</span><span class="o">.</span><span class="n">createBinary</span><span class="p">(</span><span class="s1">&#39;BasicScatteringExample.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="c1">#note: calls below must be in order that objects have been stored</span>
<span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;Ms&#39;</span><span class="p">,</span> <span class="s1">&#39;K0&#39;</span><span class="p">,</span> <span class="s1">&#39;K1&#39;</span><span class="p">,</span> <span class="s1">&#39;K2&#39;</span><span class="p">]:</span>
    <span class="nb">globals</span><span class="p">()[</span><span class="n">string</span><span class="p">]</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">tbc_dofs</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span> <span class="c1">#loading dofs of the tbc</span>
<span class="n">tbc_dofs</span> <span class="o">=</span> <span class="n">tbc_dofs</span><span class="p">[:]</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>

<span class="c1">###########################################</span>
<span class="c1"># Input parameters</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.48</span><span class="p">,</span> <span class="mf">1.60</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span> <span class="c1">#normalized angular frequency range</span>
<span class="n">nev</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1">#tbc number of eigenvalues requested at each frequency</span>

<span class="c1">###########################################</span>
<span class="c1"># Scattering initialization</span>
<span class="n">ws</span> <span class="o">=</span> <span class="n">Scattering</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="mi">0</span><span class="o">*</span><span class="n">M</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;waveguide0&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">tbc_dofs</span><span class="p">)])</span> <span class="c1">#M and K are the mass and stiffness matrices of the FE box</span>
<span class="c1">#reminder: tbc_dofs are the global degrees of freedom, set negative by convention when the normal is negative (here, we suppose n=-ey)</span>

<span class="c1">###########################################</span>
<span class="c1"># Solve waveguide problem associated with the tbc</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span> <span class="o">=</span> <span class="n">Waveguide</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">Ms</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">)</span> <span class="c1">#Ms, K0, K1 and K2 are SAFE matrices associated with the tbc (here, named &#39;waveguide0&#39;)</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nev</span><span class="p">)</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">compute_traveling_direction</span><span class="p">()</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">compute_poynting_normalization</span><span class="p">()</span>

<span class="c1">###########################################</span>
<span class="c1"># Solving scattering problem</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">4.36</span><span class="p">))</span> <span class="c1">#4.36 is the S1 wavenumber value at angular frequency 5.13 roughly (normalized values)</span>
<span class="n">mode</span> <span class="o">=</span> <span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">track_mode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.98</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#track a mode, specified by its index at a given frequency, over the whole frequency range</span>
<span class="n">ws</span><span class="o">.</span><span class="n">set_ingoing_mode</span><span class="p">(</span><span class="s1">&#39;waveguide0&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span> <span class="c1">#set mode as a single ingoing mode, coeff is 1 (here, power is also 1 thanks to poynting normalization)</span>
<span class="n">ws</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">()</span>
<span class="n">ws</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="c1">###########################################</span>
<span class="c1"># Plot reflected power coefficients vs. angular frequency</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">compute_complex_power</span><span class="p">()</span>
<span class="n">sc</span> <span class="o">=</span> <span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;complex_power&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span> <span class="n">direction</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">sc</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
<span class="n">sc</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Reflected power&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="authors-and-contributors">
<h2>7. Authors and contributors<a class="headerlink" href="#authors-and-contributors" title="Permalink to this heading"></a></h2>
<p>Waveguicsx is currently developed and maintained at Université Gustave Eiffel by Dr. Fabien Treyssède, with some contributions from Dr. Maximilien Lehujeur (github software management, python formatting, beta testing) and Dr. Pierric Mora (parallelization of loops in tutorials, beta testing). Please see the AUTHORS file for a list of contributors.</p>
<p>Feel free to contact me by email for further information or questions about waveguicsx.</p>
<p>contact: fabien.treyssede&#64;univ-eiffel.fr</p>
</section>
<section id="how-to-cite">
<h2>8. How to cite<a class="headerlink" href="#how-to-cite" title="Permalink to this heading"></a></h2>
<p>Please cite the software project as follows if used for your own projects or academic publications:</p>
<p>F. Treyssède, waveguicsx (a python library for solving complex waveguides problems), 2023; software available at https://github.com/Universite-Gustave-Eiffel/waveguicsx.</p>
<p>For theoretical details about finite element modeling of waveguide problems, here are also a few references by the author about the SAFE modeling of elastic waveguides:</p>
<p>F. Treyssède, L. Laguerre, Numerical and analytical calculation of modal excitability for elastic wave generation in lossy waveguides, Journal of the Acoustical Society of America 133 (2013), 3827–3837</p>
<p>K. L. Nguyen, F. Treyssède, C. Hazard, Numerical modeling of three-dimensional open elastic waveguides combining semi-analytical finite element and perfectly matched layer methods, Journal of Sound and Vibration 344 (2015), 158-178</p>
<p>F. Treyssède, Spectral element computation of high-frequency leaky modes in three-dimensional solid waveguides, Journal of Computational Physics 314 (2016), 341-354</p>
<p>M. Gallezot, F. Treyssède, L. Laguerre, A modal approach based on perfectly matched layers for the forced response of elastic open waveguides, Journal of Computational Physics 356 (2018), 391-409</p>
<p>And here are a few references by the author about the hybrid FE-SAFE method for modeling scattering in elastic waveguides:</p>
<p>F. Benmeddour, F. Treyssède, L. Laguerre, Numerical modeling of guided wave interaction with non-axisymmetric cracks in elastic cylinders, International Journal of Solids and Structures 48 (2011), 764-774</p>
<p>M. Gallezot, F. Treyssède, L. Laguerre, Numerical modelling of wave scattering by local inhomogeneities in elastic waveguides embedded into infinite media, Journal of Sound and Vibration 443 (2019), 310-327</p>
</section>
<section id="license">
<h2>9. License<a class="headerlink" href="#license" title="Permalink to this heading"></a></h2>
<p>Waveguicsx is freely available under the GNU GPL, version 3.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Waveguicsx - Version 2.1" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="documentation.html" class="btn btn-neutral float-right" title="Documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2024, Fabien Treyssede.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>