<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>waveguide.py &mdash; waveguicsx 2.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Tutorials" href="tutorials.html" />
    <link rel="prev" title="Documentation" href="documentation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/logo_doc.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="readme_link.html">Presentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="readme_link.html#introduction">0. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="readme_link.html#basic-examples">1. Basic examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="readme_link.html#prerequisites">2. Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="readme_link.html#installation">3. Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="readme_link.html#documentation">4. Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="readme_link.html#tutorials">5. Tutorials</a></li>
<li class="toctree-l2"><a class="reference internal" href="readme_link.html#scattering-by-local-inhomogeneities">6. Scattering by local inhomogeneities</a></li>
<li class="toctree-l2"><a class="reference internal" href="readme_link.html#authors-and-contributors">7. Authors and contributors</a></li>
<li class="toctree-l2"><a class="reference internal" href="readme_link.html#how-to-cite">8. How to cite</a></li>
<li class="toctree-l2"><a class="reference internal" href="readme_link.html#license">9. License</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="documentation.html">Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">waveguide.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-waveguicsx.scattering">scattering.py</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#three-dimensional-elastic-bar-of-square-cross-section">0. Three-dimensional elastic bar of square cross-section</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#three-dimensional-elastic-bar-of-square-cross-section-with-parallelization">1. Three-dimensional elastic bar of square cross-section with parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#three-dimensional-elastic-bar-of-square-cross-section-buried-into-a-pml-external-medium">2. Three-dimensional elastic bar of square cross-section buried into a PML external medium</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#three-dimensional-elastic-bar-of-square-cross-section-buried-into-a-pml-external-medium-using-gmsh">3. Three-dimensional elastic bar of square cross-section buried into a PML external medium using gmsh</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#excitation-of-a-three-dimensional-elastic-bar-of-circular-cross-section">4. Excitation of a three-dimensional elastic bar of circular cross-section</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#excitation-of-a-three-dimensional-elastic-bar-of-circular-cross-section-with-parallelization">5. Excitation of a three-dimensional elastic bar of circular cross-section with parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#time-response-of-a-two-dimensional-plate-excited-near-its-first-zgv-resonance">6. Time response of a two-dimensional plate excited near its first ZGV resonance</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#dispersion-curves-of-a-rail">7. Dispersion curves of a rail</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#reflection-of-lamb-modes-by-the-free-edge-of-a-plate">8. Reflection of Lamb modes by the free edge of a plate</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#reflection-and-transmission-of-pochhammer-chree-modes-inside-a-cylinder">9. Reflection and transmission of Pochhammer-Chree modes inside a cylinder</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">waveguicsx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="documentation.html">Documentation</a></li>
      <li class="breadcrumb-item active">waveguide.py</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/waveguicsx.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-waveguicsx.waveguide">
<span id="waveguide-py"></span><h1>waveguide.py<a class="headerlink" href="#module-waveguicsx.waveguide" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">waveguicsx.waveguide.</span></span><span class="sig-name descname"><span class="pre">Waveguide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_MPI.Comm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class for solving complex waveguide problems based on SLEPc eigensolver.</p>
<p>The full documentation is entirely defined in the <a href="#id1"><span class="problematic" id="id2">`</span></a>waveguide.py’ module.</p>
<p>The following matrix problem is considered: (K0-omega**2*M + 1j*k*(K1-K1^T) + k**2*K2)*U=F.
This kind of problem typically stems from the so-called SAFE (Semi-Analytical Finite Element) method.</p>
<p>The class enables to deal with complex waveguides, two-dimensional (e.g. plates) or three-dimensional (arbitrarily
shaped cross-section), inhomogeneous in the transverse directions, anisotropic. Complex-valued problems can be handled
including the effects of non-propagating modes (evanescent, inhomogeneous), viscoelastic loss (complex material
properties) or perfectly matched layers (PML) to simulate buried waveguides.</p>
<p>The free response (F=0) is an eigenvalue problem, solved iteratively by varying the parameter
which can be the angular frequency omega or the wavenumber k. In the former case, the eigenvalue is k,
while in the latter case, the eigenvalue is omega^2. The loops over the parameter (angular frequency or wavenumber)
can be parallelized, as shown in some tutorials (using mpi4py).</p>
<p>Various modal properties (energy velocity, group velocity, excitability…) can be post-processed as a function of the
frequency and plotted as dispersion curves.</p>
<p>The forced reponse (F is not 0) is solved in the frequency domain by expanding the solution as a sum of
eigenmodes using biorthogonality relationship, leading to very fast computations of excited wavefields.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># In this example, the matrices M, K0, K1, K2 and the excitation vector F are supposed to be dimensional for simplicity</span>
<span class="c1"># Yet, in practice, the problem would better be normalized to avoid ill-conditioning (see tutorials)</span>

<span class="kn">from</span> <span class="nn">waveguicsx.waveguide</span> <span class="kn">import</span> <span class="n">Waveguide</span>

<span class="c1"># Definition of the excitation signal (here, a toneburst)</span>
<span class="n">excitation</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">()</span>
<span class="n">excitation</span><span class="o">.</span><span class="n">toneburst</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="mf">400e3</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">2e-3</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="mf">100e3</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="c1">#central frequency 100 kHz, 8 cycles, duration 2 ms, sampling frequency 400 kHz</span>
<span class="n">excitation</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1">#plot time signal</span>
<span class="n">excitation</span><span class="o">.</span><span class="n">plot_spectrum</span><span class="p">()</span> <span class="c1">#plot spectrum</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">excitation</span><span class="o">.</span><span class="n">frequency</span> <span class="c1">#angular frequency range</span>

<span class="c1"># Initialization of waveguide</span>
<span class="n">wg</span> <span class="o">=</span> <span class="n">Waveguide</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span> <span class="c1">#set the parameter range (here, angular frequency)</span>

<span class="c1"># Free response (dispersion curves)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nev</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#solution of eigenvalue problem (iteration over the parameter omega), 20 eigenvalues requested at each frequency</span>
<span class="n">wg</span><span class="o">.</span><span class="n">compute_energy_velocity</span><span class="p">()</span> <span class="c1">#post-process energy velocity</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1">#plot k vs. omega</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot_energy_velocity</span><span class="p">()</span> <span class="c1">#plot ve vs. omega</span>

<span class="c1"># Computation of modal coefficients due to an excitation vector F</span>
<span class="n">wg</span><span class="o">.</span><span class="n">compute_response_coefficient</span><span class="p">(</span><span class="n">F</span><span class="o">=</span><span class="n">F</span><span class="p">)</span> <span class="c1">#F should be a PETSc vector</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot_coefficient</span><span class="p">()</span> <span class="c1">#plot modal coefficients vs. omega</span>

<span class="c1"># Forced response at degree of freedom dof and axial coordinates z (dof should be an integer)</span>
<span class="n">frequency</span><span class="p">,</span> <span class="n">response</span> <span class="o">=</span> <span class="n">wg</span><span class="o">.</span><span class="n">compute_response</span><span class="p">(</span><span class="n">dof</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="n">spectrum</span><span class="o">=</span><span class="n">excitation</span><span class="o">.</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1">#response in the frequency domain</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">frequency</span><span class="o">=</span><span class="n">frequency</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">=</span><span class="n">response</span><span class="p">)</span> <span class="c1">#define response as a Signal object</span>
<span class="n">response</span><span class="o">.</span><span class="n">plot_spectrum</span><span class="p">()</span> <span class="c1">#plot frequency response</span>
<span class="n">response</span><span class="o">.</span><span class="n">ifft</span><span class="p">()</span> <span class="c1">#response in the time domain</span>
<span class="n">response</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1">#plot time response</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<section id="attributes">
<h2>Attributes<a class="headerlink" href="#attributes" title="Permalink to this heading"></a></h2>
<dl class="simple">
<dt>comm<span class="classifier">mpi4py.MPI.Intracomm</span></dt><dd><p>MPI communicator (parallel processing)</p>
</dd>
<dt>M, K0, K1, K2<span class="classifier">petsc4py.PETSc.Mat</span></dt><dd><p>SAFE matrices</p>
</dd>
<dt>F<span class="classifier">petsc4py.PETSc.Vec</span></dt><dd><p>SAFE excitation vector</p>
</dd>
<dt>problem_type<span class="classifier">str</span></dt><dd><p>problem_type is “omega” if the varying parameter is omega, “wavenumber” if this is k</p>
</dd>
<dt>two_sided<span class="classifier">bool</span></dt><dd><p>if True, left eigenvectors will be also computed (otherwise, only right eigenvectors are computed)</p>
</dd>
<dt>target: complex number or user-defined function of the parameter</dt><dd><p>target around which eigenpairs are looked for (see method solve)</p>
</dd>
<dt>omega or wavenumber<span class="classifier">numpy.ndarray</span></dt><dd><p>the parameter range specified by the user (see method set_parameters)</p>
</dd>
<dt>evp<span class="classifier">PEP or EPS instance (SLEPc object)</span></dt><dd><p>eigensolver parameters</p>
</dd>
<dt>eigenvalues<span class="classifier">list of numpy arrays</span></dt><dd><p>list of wavenumbers or angular frequencies,
access to components with eigenvalues[ip][imode] (ip: parameter index, imode: mode index)</p>
</dd>
<dt>eigenvectors<span class="classifier">list of PETSc matrices</span></dt><dd><p>list of mode shapes,
access to components with eigenvectors[ik][idof,imode] (ik: parameter index, imode: mode index, idof: dof index)
or eigenvectors[ik].getColumnVector(imode)</p>
</dd>
<dt>eigenforces<span class="classifier">list of PETSc matrices</span></dt><dd><p>list of eigenforces (acces to components: see eigenvectors)</p>
</dd>
<dt>opposite_going<span class="classifier">list of numpy arrays</span></dt><dd><p>list of opposite-going mode (acces to components: see eigenvectors)</p>
</dd>
<dt>energy_velocity<span class="classifier">list of numpy arrays</span></dt><dd><p>list of energy velocity (access to component: see eigenvalues)</p>
</dd>
<dt>group_velocity<span class="classifier">list of numpy arrays</span></dt><dd><p>list of group velocity (access to component: see eigenvalues)</p>
</dd>
<dt>traveling_direction<span class="classifier">list of numpy arrays</span></dt><dd><p>list of traveling_direction (access to component: see eigenvalues)</p>
</dd>
<dt>pml_ratio<span class="classifier">list of numpy arrays</span></dt><dd><p>list of pml ratio, used for filtering out PML modes (access to component: see eigenvalues)</p>
</dd>
<dt>coefficient<span class="classifier">list of numpy arrays</span></dt><dd><p>list of response coefficient to excitation vector F (access to component: see eigenvalues)</p>
</dd>
<dt>excitability<span class="classifier">list of numpy arrays</span></dt><dd><p>list of excitability to excitation vector F (access to component: see eigenvalues)</p>
</dd>
<dt>complex_power<span class="classifier">list of numpy arrays</span></dt><dd><p>list of complex power flow of individual modes (access to component: see eigenvalues)</p>
</dd>
<dt>plot_scaler<span class="classifier">dictionnary</span></dt><dd><p>dictionnary containing the scaling factors of various modal properties, useful to plot results in a dimensional form</p>
</dd>
</dl>
</section>
<section id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this heading"></a></h2>
<dl class="simple">
<dt>__init__(comm:’_MPI.Comm’, M:PETSc.Mat, K0:PETSc.Mat, K1:PETSc.Mat, K2:PETSc.Mat):</dt><dd><p>Constructor, initialization of waveguide</p>
</dd>
<dt>set_parameters(omega=None, wavenumber=None, two_sided=False):</dt><dd><p>Set problem type (problem_type), the parameter range (omega or wavenumber) as well as default parameters of SLEPc eigensolver (evp);
set two_sided to True to compute left eigenvectors also (left eigenvectors are the opposite-going modes)</p>
</dd>
<dt>solve(nev=1, target=0):</dt><dd><p>Solve the eigenvalue problem repeatedly for the parameter range, solutions are stored as attributes (names: eigenvalues,
eigenvectors)</p>
</dd>
<dt>compute_eigenforce():</dt><dd><p>Compute the eigenforces for the whole parameter range and store them as an attribute (name: eigenforces)</p>
</dd>
<dt>compute_poynting_normalization():</dt><dd><p>Normalization of eigenvectors and eigenforces, so that U’=U/sqrt(<a href="#id54"><span class="problematic" id="id55">|P|</span></a>), where P is the normal component of complex Poynting vector</p>
</dd>
<dt>compute_opposite_going(plot=False):</dt><dd><p>Compute opposite-going mode pairs based on on wavenumber and biorthogonality for the whole parameter range and store
them as attributes (name: opposite_going), set plot to True to visualize the biorthogonality values of detected pairs</p>
</dd>
<dt>compute_energy_velocity():</dt><dd><p>Compute the energy velocities for the whole parameter range and store them as an attribute (name: energy_velocity)</p>
</dd>
<dt>compute_group_velocity():</dt><dd><p>Compute the group velocities for the whole parameter range and store them as an attribute (name: energy_velocity)</p>
</dd>
<dt>compute_traveling_direction():</dt><dd><p>Compute the traveling directions for the whole parameter range and store them as an attribute (name: traveling_direction)</p>
</dd>
<dt>compute_pml_ratio():</dt><dd><p>Compute the pml ratios for the whole parameter range and store them as an attribute (name: pml_ratio)</p>
</dd>
<dt>compute_response_coefficient(F, spectrum=None, wavenumber_function=None, dof=None):</dt><dd><p>Compute the response coefficients due to excitation vector F for the whole parameter range and store them as
an attribute (name: coefficient)</p>
</dd>
<dt>compute_complex_power(self):</dt><dd><p>Compute the individual complex power flow of modes given by P=-1j*omega/2*U^H*F</p>
</dd>
<dt>compute_response(dof, z, spectrum=None, wavenumber_function=None, plot=False):</dt><dd><p>Compute the response at the degree of freedom dof and the axial coordinate z for the whole frequency range</p>
</dd>
<dt>track_mode(omega_index, mode_index, threshold=0.9, plot=False):</dt><dd><p>Track a mode over the whole frequency range thanks to eigenvector similarity. The mode is specified by its
index, mode_index, at a given angular frequency index, omega_index.</p>
</dd>
<dt>plot(direction=None, pml_threshold=None, ax=None, color=”k”,  marker=”o”, markersize=2, linestyle=””, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs):</dt><dd><p>Plot dispersion curves Re(omega) vs. Re(wavenumber) using matplotlib</p>
</dd>
<dt>plot_phase_velocity(direction=None, pml_threshold=None, ax=None, color=”k”, marker=”o”, markersize=2, linestyle=””, <a href="#id5"><span class="problematic" id="id6">**</span></a>kwargs):</dt><dd><p>Plot phase velocity dispersion curves, vp=Re(omega)/Re(wavenumber) vs. Re(omega)</p>
</dd>
<dt>plot_attenuation(direction=None, pml_threshold=None, ax=None, color=”k”, marker=”o”, markersize=2, linestyle=””, <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs):</dt><dd><p>Plot attenuation dispersion curves, Im(wavenumber) vs. Re(omega) if omega is the parameter,
or Im(omega) vs. Re(omega) if wavenumber is the parameter</p>
</dd>
<dt>plot_energy_velocity(direction=None, pml_threshold=None, ax=None, color=”k”, marker=”o”, markersize=2, linestyle=””, <a href="#id9"><span class="problematic" id="id10">**</span></a>kwargs):</dt><dd><p>Plot energy velocity dispersion curves, ve vs. Re(omega)</p>
</dd>
<dt>plot_group_velocity(direction=None, pml_threshold=None, ax=None, color=”k”, marker=”o”, markersize=2, linestyle=””, <a href="#id11"><span class="problematic" id="id12">**</span></a>kwargs):</dt><dd><p>Plot group velocity dispersion curves, vg vs. Re(omega)</p>
</dd>
<dt>plot_coefficient(direction=None, pml_threshold=None, ax=None, color=”k”, marker=”o”, markersize=2, linestyle=””, <a href="#id13"><span class="problematic" id="id14">**</span></a>kwargs):</dt><dd><p>Plot response coefficients as a function of frequency, <a href="#id56"><span class="problematic" id="id57">|q|</span></a> vs. Re(omega)</p>
</dd>
<dt>plot_excitability(direction=None, pml_threshold=None, ax=None, color=”k”, marker=”o”, markersize=2, linestyle=””, <a href="#id15"><span class="problematic" id="id16">**</span></a>kwargs):</dt><dd><p>Plot excitability as a function of frequency, <a href="#id58"><span class="problematic" id="id59">|e|</span></a> vs. Re(omega)</p>
</dd>
<dt>plot_spectrum(index=0, ax=None, color=”k”, marker=”o”, markersize=2, linestyle=””, <a href="#id17"><span class="problematic" id="id18">**</span></a>kwargs):</dt><dd><p>Plot the spectrum, Im(eigenvalues) vs. Re(eigenvalues), for the parameter index specified by the user</p>
</dd>
<dt>set_plot_scaler(length=1, time=1, mass=1, dim=3):</dt><dd><p>Define the characteristic length, time, mass, as well as dim, and calculate the scaling factors of modal
properties, which are stored in the attribute name plot_scaler (useful to visualize plots in a dimensional form)</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.set_parameters">
<span class="sig-name descname"><span class="pre">set_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">complex</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavenumber</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">complex</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_sided</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.set_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.set_parameters" title="Permalink to this definition"></a></dt>
<dd><p>Set the parameter range (omega or wavenumber) as well as default parameters of the SLEPc eigensolver (evp).
The user must specify the parameter omega or wavenumber, but not both.
This method generates the attributes omega (or wavenumber) and evp.
After calling this method, various SLEPc parameters can be set by changing the attribute evp manually.
Set two_sided=True for solving left eigenvectors also.</p>
<section id="parameters">
<h3>Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>omega or wavenumber<span class="classifier">numpy.ndarray</span></dt><dd><p>the parameter range specified by the user</p>
</dd>
<dt>two_sided<span class="classifier">bool</span></dt><dd><p>False if left eigenvectiors are not needed, True if they must be solved also</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.solve" title="Permalink to this definition"></a></dt>
<dd><p>Solve the dispersion problem, i.e. the eigenvalue problem repeatedly for the parameter range (omega or wavenumber).
The solutions are stored in the attributes eigenvalues and eigenvectors.
If two_sided is True, left eigensolutions are also solved.</p>
<p>Note: left eigensolutions correspond to opposite-going modes and are hence added to the right eigensolutions
(i.e. in eigenvalues and eigenvectors) after removing any possible duplicates.</p>
<section id="id19">
<h3>Parameters<a class="headerlink" href="#id19" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>nev<span class="classifier">int</span></dt><dd><p>number of eigenpairs requested</p>
</dd>
<dt>target<span class="classifier">complex number or user-defined function of the parameter, optional (default: 0)</span></dt><dd><p>target around which eigenpairs are looked for
a small shift might sometimes prevent errors (e.g. zero pivot with dirichlet bc)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.compute_eigenforces">
<span class="sig-name descname"><span class="pre">compute_eigenforces</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.compute_eigenforces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.compute_eigenforces" title="Permalink to this definition"></a></dt>
<dd><p>Post-process the eigenforces F=(K1^T+1j*k*K2)*U for every mode in the whole parameter range</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.compute_poynting_normalization">
<span class="sig-name descname"><span class="pre">compute_poynting_normalization</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.compute_poynting_normalization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.compute_poynting_normalization" title="Permalink to this definition"></a></dt>
<dd><p>Post-process the normalization of eigenvectors and eigenforces, so that U’=U/sqrt(<a href="#id60"><span class="problematic" id="id61">|P|</span></a>),
where P is the normal component of complex Poynting vector (P=-1j*omega/2*U^H*F).
After normalization, every mode is such that <a href="#id20"><span class="problematic" id="id21">|</span></a>P|=1 and the attribute _poynting_normalization is set to True.
Normalization is not mandatory but, when applied, has to be done before any response coefficient computation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.compute_energy_velocity">
<span class="sig-name descname"><span class="pre">compute_energy_velocity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.compute_energy_velocity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.compute_energy_velocity" title="Permalink to this definition"></a></dt>
<dd><p>Post-process the energy velocity ve=Re(P)/Re(E) for every mode in the whole parameter range, where P is the
normal component of complex Poynting vector and E is the total energy (cross-section time-averaged).
Warning in case of PML: the integration is currently applied over the whole cross-section (including PML),
the so-defined energy velocity is questionable.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.compute_opposite_going">
<span class="sig-name descname"><span class="pre">compute_opposite_going</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.compute_opposite_going"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.compute_opposite_going" title="Permalink to this definition"></a></dt>
<dd><p>Post-process the pairing of opposite-going modes, based on wavenumber and biorthogonality criteria, and store them
as a an attribute (name: opposite_going, -1 value for unpaired modes).
Compute their biorthogonality normalization factors, Um^T*F-m - U-m^T*Fm, where m and -m denote opposite-going
modes, for the whole parameter range and store them as an attribute (name: _biorthogonality_factor).
If plot is set to True, the biorthogonality criterion found by the algorithm is plotted as a function
of frequency index, allowing visual check that there is no values close to zero (a factor close to zero probably means
a lack of biorthogonality). The biorthogonality criterion is defined as <a href="#id62"><span class="problematic" id="id63">|biorthogonality_factor*omega/4|</span></a>.</p>
<p>Notes:</p>
<ul class="simple">
<li><p>when an unpaired mode is found, the value -1 is stored in opposite_going (and NaN value in _biorthogonality_factor),
meaning that this mode will be discarded in the computation of group velocity, traveling direction, coefficient and
excitability (NaN values stored)</p></li>
<li><p>if modes with lack of biorthogonality or two many unpaired modes occur, try to recompute the eigenproblem by
increasing the accuracy (e.g. reducing the tolerance)</p></li>
<li><p>lack of biorthogonality may be also due to multiple modes (*); in this case, try to use an unstructured mesh instead</p></li>
<li><p>if two_sided is True, lack of biorthogonolity may occur for specific target: try another target (e.g. add a small
imaginary part)</p></li>
</ul>
<p>(*) e.g. flexural modes in a cylinder with structured mesh</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.compute_group_velocity">
<span class="sig-name descname"><span class="pre">compute_group_velocity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.compute_group_velocity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.compute_group_velocity" title="Permalink to this definition"></a></dt>
<dd><p>Post-process the group velocity, vg=1/Re(dk/domega) for every mode in the whole parameter range (opposite-going modes
required). For unpaired modes, NaN values are set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.compute_traveling_direction">
<span class="sig-name descname"><span class="pre">compute_traveling_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.compute_traveling_direction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.compute_traveling_direction" title="Permalink to this definition"></a></dt>
<dd><p>Post-process the traveling direction, +1 or -1, for every mode in the whole parameter range,
using the sign of Im(k + 1j*delta/v) where delta is the imaginary shift used for analytical
continuation of k, and v is the group velocity (or, if not available, the energy velocity).
This criterion is based on the limiting absorption principle (theoretically, vg should be used
instead of ve). For unpaired modes, NaN values are set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.compute_pml_ratio">
<span class="sig-name descname"><span class="pre">compute_pml_ratio</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.compute_pml_ratio"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.compute_pml_ratio" title="Permalink to this definition"></a></dt>
<dd><p>Post-process the pml ratio (useful to filter out PML mode), given by 1-Im(Ek)/<a href="#id64"><span class="problematic" id="id65">|Ek|</span></a> where Ek denotes
the “complex” kinetic energy, for every mode in the whole parameter range.      
Reminder: the pml ratio tends to 1 for mode shapes vanishing inside the PML.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.compute_response_coefficient">
<span class="sig-name descname"><span class="pre">compute_response_coefficient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavenumber_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.compute_response_coefficient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.compute_response_coefficient" title="Permalink to this definition"></a></dt>
<dd><p>Computation of modal coefficients due to the excitation vector F for every mode in the whole omega range (opposite-going
eigenvectors are required).
Modal coefficients qm are defined from: U(z,omega) = sum qm(omega)*Um(omega)*exp(i*km*z), m=1…M, omega denotes the
angular frequency.
For unpaired modes, NaN values are set.
Assumption: the source is centred at z=0.</p>
<p>Note: spectrum and wavenumber_function can be specified in compute_response(…) instead of     
compute_response_coefficient(…), but not in both functions in the same time (otherwise the excitation will be
modulated twice)</p>
<section id="id22">
<h3>Parameters<a class="headerlink" href="#id22" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>F<span class="classifier">PETSc vector</span></dt><dd><p>SAFE excitation vector</p>
</dd>
<dt>spectrum<span class="classifier">numpy.ndarray</span></dt><dd><p>when specified, spectrum is a vector of length omega  used to modulate F in terms of frequency (default: 1 for
all frequencies)</p>
</dd>
<dt>wavenumber_function: python function</dt><dd><p>when specified, wavenumber_function is a python function used to modulate F in terms of wavenumber (example:
wavenumber_function = lambda x: np.sin(x), default: 1 for all wavenumbers, i.e. source localized at z=0)</p>
</dd>
<dt>dof<span class="classifier">int</span></dt><dd><p>when specified, it calculates the modal excitability (stored in the attribute excitability), i.e. qm*Um at
the degree of freedom dof and for a unit excitation vector (i.e. such that the sum of the elements of F is
equal to 1)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.compute_complex_power">
<span class="sig-name descname"><span class="pre">compute_complex_power</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.compute_complex_power"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.compute_complex_power" title="Permalink to this definition"></a></dt>
<dd><p>Post-process the individual complex power flow of modes given by P=-1j*omega/2*U^H*F (normal
component of complex Poynting vector), where U and F denote the eigenvector 
and eigenforce of a single mode. The ‘usual’ power is given by the real part.</p>
<p>Notes:</p>
<ul class="simple">
<li><p>For lossy media (e.g. with viscoelasticity or with PML), it should be reminded that the individual power
should be carefully handled: the power of a sum is not equal to the sum of powers because Auld’s complex
biorthogonality relation does no longer hold</p></li>
<li><p>This inequality also generally applies between two multiple modes if any(*); in this case,
try to use an unstructured mesh instead?</p></li>
<li><p>Warning in case of PML: integration is currently done over the whole cross-section (see also
compute_energy_velocity), the so-defined complex power flow is questionable</p></li>
</ul>
<p>(*) e.g. flexural modes in a cylinder with structured mesh, whether the medium is lossy or lossless</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.compute_response">
<span class="sig-name descname"><span class="pre">compute_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dof</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavenumber_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.compute_response"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.compute_response" title="Permalink to this definition"></a></dt>
<dd><p>Post-process the response (modal expansion) at the degree of freedom dof and the axial coordinate z, for the whole
frequency range.
The outputs are frequency, a numpy 1d array of size len(omega), and response, a numpy 2d array of size len(dof or
z)*len(omega).
dof and z cannot be both vectors, except if omega_index is specified or omega is scalar (single frequency computation):
in that case, the array response is of size len(z)*len(dof), which can be useful to plot the whole field at a single
frequency.</p>
<p>The response at each frequency omega is calculated from:
U(z,omega) = sum qm(omega)*Um(omega)*exp(i*km*z), m=1…M,
where z is the receiver position along the waveguide axis.
M is the number of modes traveling in the proper direction, positive if z is positive, negative if z is negative.
The pairing of opposite-going eigenvectors is required, unpaired modes are discarded from the expansion.</p>
<p>The outputs frequency and response are made dimensional when values in plot_scaler are not set to 1.</p>
<p>Assumption: the source is assumed to be centred at z=0.</p>
<p>Warning: the response calculation is only valid if z lies oustide the source region.</p>
<p>Note: spectrum and wavenumber_function can be specified in compute_response_coefficient(…) instead
of compute_response(…), but not in both functions in the same time (otherwise the excitation will be modulated twice).</p>
<section id="id23">
<h3>Parameters<a class="headerlink" href="#id23" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>dof<span class="classifier">numpy array of integer</span></dt><dd><p>dof where the response is computed</p>
</dd>
<dt>z<span class="classifier">numpy array</span></dt><dd><p>axial coordinate where the response is computed</p>
</dd>
<dt>omega_index<span class="classifier">int</span></dt><dd><p>omega index to compute the response at a single frequency, allowing the consideration of multiple dof and z</p>
</dd>
<dt>spectrum<span class="classifier">numpy.ndarray</span></dt><dd><p>when specified, spectrum is a vector of length omega  used to modulate F in terms of frequency (default: 1 for
all frequencies)</p>
</dd>
<dt>wavenumber_function: python function</dt><dd><p>when specified, wavenumber_function is a python function used to modulate F in terms of wavenumber (example:
wavenumber_function = lambda x: np.sin(x), default: 1 for all wavenumbers, i.e. source localized at z=0)</p>
</dd>
<dt>plot<span class="classifier">bool</span></dt><dd><p>if set to True, the magnitude and phase of response are plotted as a function of frequency</p>
</dd>
</dl>
</section>
<section id="returns">
<h3>Returns<a class="headerlink" href="#returns" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>frequency<span class="classifier">numpy 1d array</span></dt><dd><p>the frequency vector, i.e. omega/(2*pi)</p>
</dd>
<dt>response<span class="classifier">numpy array (1d or 2d)</span></dt><dd><p>the matrix response</p>
</dd>
</dl>
<p>ll_abs : matplotlib list of lines for magnitude plot when plot is set to True
ll_angle : matplotlib list of lines for phase plot when plot is set to True</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.track_mode">
<span class="sig-name descname"><span class="pre">track_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.track_mode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.track_mode" title="Permalink to this definition"></a></dt>
<dd><p>Track a mode over the whole frequency range.
The mode is specified by its index, mode_index, at a given angular frequency index, omega_index.
Tracking is performed thanks to similarity between eigenvectors and eigenforces (value between 0 and 1).
Tracking is stopped if similarity becomes lower than threshold.
It returns mode, the index list identifying the mode position at each frequency (index is set to -1
for frequencies at which the mode has not been successfully tracked due to low similarity).
If plot is set to True, the real and imaginary parts of eigenvalue are plotted w.r.t. frequency index,
for visual check that the desired mode has been properly tracked.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.plot_phase_velocity">
<span class="sig-name descname"><span class="pre">plot_phase_velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.plot_phase_velocity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.plot_phase_velocity" title="Permalink to this definition"></a></dt>
<dd><p>Plot phase velocity dispersion curves, vp vs. Re(omega), where omega is replaced with frequency
for dimensional results. Parameters and Returns: see plot(…).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.plot_attenuation">
<span class="sig-name descname"><span class="pre">plot_attenuation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.plot_attenuation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.plot_attenuation" title="Permalink to this definition"></a></dt>
<dd><p>Plot attenuation dispersion curves, Im(wavenumber) vs. Re(omega) if omega is the parameter,
or Im(omega) vs. Re(wavenumber) if wavenumber is the parameter, where omega is replaced with frequency
for dimensional results. Parameters and Returns: see plot(…).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.plot_energy_velocity">
<span class="sig-name descname"><span class="pre">plot_energy_velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.plot_energy_velocity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.plot_energy_velocity" title="Permalink to this definition"></a></dt>
<dd><p>Plot energy velocity dispersion curves, ve vs. Re(omega), where omega is replaced with frequency
for dimensional results. Parameters and Returns: see plot(…).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.plot_group_velocity">
<span class="sig-name descname"><span class="pre">plot_group_velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.plot_group_velocity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.plot_group_velocity" title="Permalink to this definition"></a></dt>
<dd><p>Plot group velocity dispersion curves, vg vs. Re(omega), where omega is replaced with frequency
for dimensional results. Parameters and Returns: see plot(…).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.plot_coefficient">
<span class="sig-name descname"><span class="pre">plot_coefficient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.plot_coefficient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.plot_coefficient" title="Permalink to this definition"></a></dt>
<dd><p>Plot response coefficients as a function of frequency, <a href="#id66"><span class="problematic" id="id67">|q|</span></a> vs. Re(omega), where omega is replaced with frequency
for dimensional results. Parameters and Returns: see plot(…).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.plot_excitability">
<span class="sig-name descname"><span class="pre">plot_excitability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.plot_excitability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.plot_excitability" title="Permalink to this definition"></a></dt>
<dd><p>Plot excitability as a function of frequency, <a href="#id68"><span class="problematic" id="id69">|e|</span></a> vs. Re(omega), where omega is replaced with frequency
for dimensional results. Parameters and Returns: see plot(…).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.plot_complex_power">
<span class="sig-name descname"><span class="pre">plot_complex_power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.plot_complex_power"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.plot_complex_power" title="Permalink to this definition"></a></dt>
<dd><p>Plot complex power flow of individual modes as a function of frequency, Re(P) and Im(P) vs. Re(omega), 
where omega is replaced with frequency for dimensional results. Gray color is used for the imaginary part.
Parameters and Returns: see plot(…).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pml_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'o'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.plot" title="Permalink to this definition"></a></dt>
<dd><p>Plot dispersion curves y[1](y[0]) vs. x[1](x[0]) as scatter plot.
If the index list, mode, is specified by the user, a single mode is plotted as a continuous single colored curve
(the index list mode can be obtained from method track_mode(…)).</p>
<section id="id24">
<h3>Parameters<a class="headerlink" href="#id24" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>x, y, c: list</dt><dd><p>x[0], y[0], c[0] are strings corresponding to modal properties for the x-axis, y-axis and marker colors respectively
(these strings can be: ‘omega’, ‘wavenumber’, ‘energy_velocity’, ‘group_velocity’, ‘pml_ratio’, ‘eigenvalues’,
‘excitability’, ‘eigenvectors’, ‘eigenforces’, ‘coefficient’, ‘power flow’, ‘frequency’, ‘attenuation’, ‘phase_velocity’),
x[1], y[1], c[1] are the functions applied to x[0], y[0] and c[0] respectively (e.g. np.abs, np.angle, np.real, np.imag, etc.).
If x is None but not y, x is set to [‘omega’, np.real] if results are normalized, or set to [‘frequency’, np.real] if they are
dimensional. If both x and are None, plot dispersion curves Re(omega) or Re(frequency) vs. Re(wavenumber).
If c is None, a single color is used for coloring markers (given by the input variable color).</p>
</dd>
<dt>direction: int</dt><dd><p>+1 for positive-going modes, -1 for negative-going modes, None for plotting all modes</p>
</dd>
<dt>pml_threshold: float</dt><dd><p>threshold to filter out PML modes (modes such that pml_ratio&lt;pml_threshold)</p>
</dd>
<dt>mode: index list</dt><dd><p>index list identifying the mode position at each frequency</p>
</dd>
<dt>ax: matplotlib axis</dt><dd><p>the matplotlib axis on which to plot data (created if None)</p>
</dd>
</dl>
<p>color: str, marker: str, markersize: int, linestyle: str, <a href="#id25"><span class="problematic" id="id26">**</span></a>kwargs are passed to ax.plot</p>
</section>
<section id="id27">
<h3>Returns<a class="headerlink" href="#id27" title="Permalink to this heading"></a></h3>
<p>sc: the matplotlib collection</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.set_plot_scaler">
<span class="sig-name descname"><span class="pre">set_plot_scaler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.set_plot_scaler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.set_plot_scaler" title="Permalink to this definition"></a></dt>
<dd><p>Define the characteristic length, time and mass in order to visualize plots in a dimensional form (by default, they are equal to 1).
Set dim=3 for three-dimensional waveguides, dim=2 for two-dimensional waveguides (e.g. plates).
Scaling factors for ‘omega’, ‘wavenumber’, ‘energy_velocity’, ‘group_velocity’, ‘pml_ratio’, ‘eigenvalues’, ‘excitability’,
‘eigenvectors’, ‘eigenforces’, ‘coefficient’, ‘complex_power’, ‘frequency’, ‘attenuation’, ‘phase_velocity’ are stored in the
attribute name plot_scaler.
If poynting normalization has already been applied, then the scalers for ‘eigenvectors’, ‘eigenforces’ and ‘coefficient’ are such that
the dimensional cross-section power flow of eigenmodes is equal to 1 Watt (if no poynting normalization applied, these scalers are
left to 1).
Reminder: while the dimension of U (displacement) is in meter, the dimension of F (force) is in Newton for 3D waveguides
and in Newton/meter for 2D waveguides (F is in mass*length**(dim-2)/time**2).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Waveguide.plot_spectrum">
<span class="sig-name descname"><span class="pre">plot_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'o'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Waveguide.plot_spectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Waveguide.plot_spectrum" title="Permalink to this definition"></a></dt>
<dd><p>Plot the spectrum, Im(k) vs. Re(k) computed for omega[index] (if the parameter is the frequency),
or Im(omega) vs. Re(omega) for wavenumber[index] (if the parameter is the wavenumber).</p>
<section id="id28">
<h3>Parameters<a class="headerlink" href="#id28" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>index: int</dt><dd><p>parameter index</p>
</dd>
<dt>c: list</dt><dd><p>c[0] is a string (must be an attribute of self) and c[1] is a function used for coloring markers,
a single color (given by the input variable color) is used if c is None</p>
</dd>
<dt>ax: matplotlib axis</dt><dd><p>the matplotlib axis on which to plot data (created if None)</p>
</dd>
</dl>
<p>color: str, marker: str, markersize: int, linestyle: str, <a href="#id29"><span class="problematic" id="id30">**</span></a>kwargs are passed to ax.plot</p>
</section>
<section id="id31">
<h3>Returns<a class="headerlink" href="#id31" title="Permalink to this heading"></a></h3>
<p>sc: the matplotlib collection</p>
</section>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Signal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">waveguicsx.waveguide.</span></span><span class="sig-name descname"><span class="pre">Signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">waveform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Signal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Signal" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class for handling signals in the time domain and in the frequency domain</p>
<p>Reminder:</p>
<ul class="simple">
<li><p>the sampling frequency fs must be at least twice the highest excited frequency (fs&gt;=2fmax)</p></li>
<li><p>the time duration T must be large enough to capture the slowest wave at z, the source-receiver distance</p></li>
</ul>
<p>Fourier transform definition used: X(f) = 2/T * integral of x(t)*exp(+i*omega*t)*dt</p>
<p>Two remarks:</p>
<ol class="arabic simple">
<li><p>this is not the numpy fft function convention, which is in exp(-i*omega*t)</p></li>
<li><p>the true amplitude of the Fourier transform, when needed, has to be obtained by
multiplying the output (spectrum) by the scalar T/2, where T is the duration of the time signal
(with the above definition: the division by T simplifies dimensionless analyses,
and the factor 2 is used because only the positive part of the spectrum is considered)</p></li>
</ol>
<p>Complex Fourier transform:</p>
<p>A complex Fourier transform is applied if alpha is set to a nonzero value.
The frequency vector has then an imaginary part, constant and equal to alpha/(2*pi).
Complex frequency computations can be useful for the analysis of long time duration signals (avoids aliasing).
A good choice is alpha = log(50)/T.
Note that the first frequency component is kept in that case (the frequency has a zero real part
but non-zero imaginary part).</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mysignal</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="o">/</span><span class="mf">5e-4</span><span class="p">)</span>
<span class="n">mysignal</span><span class="o">.</span><span class="n">toneburst</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="mf">5000e3</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">5e-4</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="mf">100e3</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">mysignal</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">mysignal</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span>
<span class="n">mysignal</span><span class="o">.</span><span class="n">plot_spectrum</span><span class="p">()</span>
<span class="n">mysignal</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">coeff</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mysignal</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<section id="id32">
<h2>Attributes<a class="headerlink" href="#id32" title="Permalink to this heading"></a></h2>
<dl class="simple">
<dt>time<span class="classifier">numpy 1d array</span></dt><dd><p>time vector</p>
</dd>
<dt>waveform<span class="classifier">numpy nd array</span></dt><dd><p>waveform vectors stacked as rows (waveform is an array of size number_of_signals*len(time))</p>
</dd>
<dt>frequency<span class="classifier">numpy 1d array</span></dt><dd><p>frequency vector</p>
</dd>
<dt>spectrum<span class="classifier">numpy nd array</span></dt><dd><p>spectrum vectors stacked as rows (spectrum is an array of size number_of_signals*len(frequency))</p>
</dd>
<dt>alpha<span class="classifier">float</span></dt><dd><p>decaying parameter to apply complex Fourier transform (useful for long time duration signal)</p>
</dd>
</dl>
</section>
<section id="id33">
<h2>Methods<a class="headerlink" href="#id33" title="Permalink to this heading"></a></h2>
<dl class="simple">
<dt>__init__(time=None, waveform=None, frequency=None, spectrum=None, alpha=0):</dt><dd><p>Constructor, initialization of signal (specify either waveform vs. time or spectrum vs. frequency)</p>
</dd>
<dt>fft():</dt><dd><p>Compute Fourier transform, results are stored as attributes (names: frequency, spectrum)</p>
</dd>
<dt>ifft(coeff=1):</dt><dd><p>Compute inverse Fourier transform, results are stored as attributes (names: time, waveform)</p>
</dd>
<dt>ricker(fs, T, fc):</dt><dd><p>Generate a Ricker signal</p>
</dd>
<dt>toneburst(fs, T, fc, n):</dt><dd><p>Generate a toneburst signal</p>
</dd>
<dt>chirp(fs, T, f0, f1, chirp_duration):</dt><dd><p>Generate a chirp signal</p>
</dd>
<dt>plot(ax=None, color=”k”, linewidth=1, linestyle=”-”, <a href="#id34"><span class="problematic" id="id35">**</span></a>kwargs):</dt><dd><p>Plot time waveform (waveform vs. time)</p>
</dd>
<dt>plot_spectrum(ax=None, color=”k”, linewidth=1, linestyle=”-”, <a href="#id36"><span class="problematic" id="id37">**</span></a>kwargs):</dt><dd><p>Plot the spectrum (spectrum vs. frequency), in magnitude and phase</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Signal.fft">
<span class="sig-name descname"><span class="pre">fft</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Signal.fft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Signal.fft" title="Permalink to this definition"></a></dt>
<dd><p>Compute Fourier transform (positive frequency part only, time waveform are assumed to be real).
If the number of time steps is odd, one point is added.
The zero frequency, if any, is suppressed.
Results are stored as attributes (names: frequency, spectrum).
spectrum is an array of size number_of_signals*len(frequency)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Signal.ifft">
<span class="sig-name descname"><span class="pre">ifft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Signal.ifft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Signal.ifft" title="Permalink to this definition"></a></dt>
<dd><p>Compute inverse Fourier transform (only the positive frequency part is needed, time waveform are assumed to be real).
Zero padding is applied in the low-frequency range (if missing) and in the high-frequency range (if coeff is greater than 1).
Zero padding in the high frequency range is applied up to the frequency coeff*max(frequency).
Results are stored as attributes (names: time, waveform).
waveform is an array of size number_of_signals*len(time).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Signal.ricker">
<span class="sig-name descname"><span class="pre">ricker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Signal.ricker"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Signal.ricker" title="Permalink to this definition"></a></dt>
<dd><p>Generate a Ricker wavelet signal of unit amplitude (fs: sampling frequency, T: time duration, fc: Ricker central frequency)</p>
<p>Note that for better accuracy:</p>
<ul class="simple">
<li><p>fs is rounded so that fs/fc is an integer</p></li>
<li><p>T is adjusted so that the number of points is even</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Signal.toneburst">
<span class="sig-name descname"><span class="pre">toneburst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Signal.toneburst"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Signal.toneburst" title="Permalink to this definition"></a></dt>
<dd><p>Generate a toneburst signal (fs: sampling frequency, T: time duration, fc: central frequency, n: number of cycles).
This signal is a Hanning-modulated n cycles sinusoidal toneburst centred at fc Hz (with unit amplitude).
For this kind of excitation, fmax can be considered as 2*fc roughly, hence one should choose fs&gt;=4fc.</p>
<p>Note that for better accuracy:</p>
<ul class="simple">
<li><p>fs is rounded so that fs/fc is an integer</p></li>
<li><p>T is adjusted so that the number of points is even</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Signal.chirp">
<span class="sig-name descname"><span class="pre">chirp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chirp_duration</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Signal.chirp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Signal.chirp" title="Permalink to this definition"></a></dt>
<dd><p>Generate a chirp of unit amplitude (fs: sampling frequency, T: time duration, f0: first frequency, f1: last frequency, chirp_duration: time to sweep from f0 to f1).
Note that for better accuracy, T is adjusted so that the number of points is even.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Signal.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linewidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linestyle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Signal.plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Signal.plot" title="Permalink to this definition"></a></dt>
<dd><p>Plot time waveform (waveform vs. time)</p>
<section id="id38">
<h3>Parameters<a class="headerlink" href="#id38" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>ax: matplotlib axis</dt><dd><p>the matplotlib axis on which to plot data (created if None)</p>
</dd>
</dl>
<p>color: str, linewidth: int, linestyle: str, <a href="#id39"><span class="problematic" id="id40">**</span></a>kwargs are passed to ax.plot</p>
</section>
<section id="id41">
<h3>Returns<a class="headerlink" href="#id41" title="Permalink to this heading"></a></h3>
<p>ll: the matplotlib list of lines</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.waveguide.Signal.plot_spectrum">
<span class="sig-name descname"><span class="pre">plot_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linewidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linestyle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/waveguide.html#Signal.plot_spectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.waveguide.Signal.plot_spectrum" title="Permalink to this definition"></a></dt>
<dd><p>Plot the spectrum (spectrum vs. frequency), in magnitude and phase</p>
<section id="id42">
<h3>Parameters<a class="headerlink" href="#id42" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>ax: matplotlib axis</dt><dd><p>the matplotlib axis on which to plot data (created if None)</p>
</dd>
</dl>
<p>color: str, linewidth: int, linestyle: str, <a href="#id43"><span class="problematic" id="id44">**</span></a>kwargs are passed to ax.plot</p>
</section>
<section id="id45">
<h3>Returns<a class="headerlink" href="#id45" title="Permalink to this heading"></a></h3>
<p>ll_abs: the matplotlib list of lines for magnitude plot
ll_angle: same but for phase plot</p>
</section>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="module-waveguicsx.scattering">
<span id="scattering-py"></span><h1>scattering.py<a class="headerlink" href="#module-waveguicsx.scattering" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="waveguicsx.scattering.Scattering">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">waveguicsx.scattering.</span></span><span class="sig-name descname"><span class="pre">Scattering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">_MPI.Comm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tbcs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/scattering.html#Scattering"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.scattering.Scattering" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class for solving scattering problems by local inhomogeneities in complex waveguides based on PETSc.</p>
<p>The full documentation is entirely defined in the <a href="#id46"><span class="problematic" id="id47">`</span></a>scattering.py’ module.</p>
<p>The following matrix problem is considered: (K-omega**2*M-1j*omega*C)*U=F.
This kind of problem typically typically stems from a finite element (FE) model of a small portion of waveguide
including a local inhomogeneity (e.g. defects). The cross-section extremities of the truncated FE model are then
handled as transparent boundary conditions (BCs) to reproduce semi-infinite waveguides.
The so-obtained scattering problem is solved repeatedly for each frequency. The loops over the angular frequency can
be parallelized, as shown in some tutorials (using mpi4py).</p>
<p>This class enables to deal with scattering in complex waveguides, two-dimensional (e.g. plates) or three-dimensional
(arbitrarily shaped cross-section), inhomogeneous in the transverse directions, anisotropic. Complex-valued problems
can be handled including the effects of non-propagating modes (evanescent, inhomogeneous), viscoelastic loss (complex
material properties) or perfectly matched layers (PML) to simulate buried waveguides.</p>
<p>Transparent BCs are Waveguide objects, which must have been solved prior to the scattering
problem solution, yielding the following object attributes: omega, eigenvalues, eigenvectors, eigenforces and traveling
direction (see waveguide.py module for details). Transparent BCs are localized by their degrees of
freedom in the global vector U. This means that the local degree of freedom i of a given eigenvector/eigenforce
stored in a Waveguide object is located at the global degree of freedom dofs[i] of the FE model.</p>
<p>The user must supply the following inputs:
- K, M, C, the global FE matrices (stiffness, mass and viscous damping)
- F and F_spectrum, the global FE vector of internal excitation  (i.e. sources inside the FE model), if any,</p>
<blockquote>
<div><p>and its spectrum</p>
</div></blockquote>
<ul class="simple">
<li><p>tbcs, a list of pairs (name, dofs) which characterize the transparent BCs, where name is a string specifying the
attribute name of a given transparent BC (this attribute will be a Waveguide object) and dofs is a numpy array
of the global degrees of freedom for this transparent BC.</p></li>
<li><p>the ingoing mode coefficients, specified by the attribute coefficient in each transparent BC</p></li>
</ul>
<p>Important convention: if the waveguide axis of a transparent BC is oriented outward (i.e. outside the FE box), dofs are
positive, but if oriented inward (i.e. inside the FE box), a negative sign has to be assigned to dofs by the user.</p>
<p>The solution to the scattering problem yields:
- the displacement U of the FE model for each angular frequency omega
- the outgoing modal coefficients of every transparent BC and for each omega
- the energy balance post-processed for each angular frequency</p>
<blockquote>
<div><p>which enables to check the error due to the modal truncature introduced in the transparent BCs.</p>
</div></blockquote>
<p>See Attributes below for more details.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># This simple example involves only one transparent boundary condition (e.g. waveguide scattering by a free edge)</span>
<span class="c1"># The tbc (the &quot;inlet&quot;) is supposed to be at the left-hand side of the FE box so that its outward normal is negative</span>

<span class="kn">from</span> <span class="nn">waveguicsx.waveguide</span> <span class="kn">import</span> <span class="n">Waveguide</span>
<span class="kn">from</span> <span class="nn">waveguicsx.scattering</span> <span class="kn">import</span> <span class="n">Scattering</span>

<span class="c1"># Input parameters</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.48</span><span class="p">,</span> <span class="mf">1.60</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span> <span class="c1">#normalized angular frequency range</span>
<span class="n">nev</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1">#tbc number of eigenvalues requested at each frequency</span>

<span class="c1"># Scattering initialization</span>
<span class="n">ws</span> <span class="o">=</span> <span class="n">Scattering</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="mi">0</span><span class="o">*</span><span class="n">M</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;waveguide0&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">tbc_dofs</span><span class="p">)])</span> <span class="c1">#M and K are the mass and stiffness matrices of the FE box</span>
<span class="c1">#reminder: tbc_dofs are the global degrees of freedom, set negative by convention when the normal is negative (here, we suppose n=-ey)</span>

<span class="c1">#Solve waveguide problem associated with the tbc</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span> <span class="o">=</span> <span class="n">Waveguide</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">Ms</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">)</span> <span class="c1">#Ms, K0, K1 and K2 are SAFE matrices associated with the tbc (here, named &#39;waveguide0&#39;)</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nev</span><span class="p">)</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">compute_traveling_direction</span><span class="p">()</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">compute_poynting_normalization</span><span class="p">()</span>

<span class="c1"># Solving scattering problem</span>
<span class="n">mode</span> <span class="o">=</span> <span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">track_mode</span><span class="p">(</span><span class="n">frequency_index</span><span class="p">,</span> <span class="n">mode_index</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.98</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#track a mode, specified by its index at a given frequency, over the whole frequency range</span>
<span class="n">ws</span><span class="o">.</span><span class="n">set_ingoing_mode</span><span class="p">(</span><span class="s1">&#39;waveguide0&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span> <span class="c1">#set mode as a single ingoing mode, coeff is 1 (here, power is also 1 thanks to poynting normalization)</span>
<span class="n">ws</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">()</span>
<span class="n">ws</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="c1"># Plot reflected power coefficients vs. angular frequency</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">compute_complex_power</span><span class="p">()</span>
<span class="n">ws</span><span class="o">.</span><span class="n">waveguide0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;complex_power&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span> <span class="n">direction</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<section id="id48">
<h2>Attributes<a class="headerlink" href="#id48" title="Permalink to this heading"></a></h2>
<dl>
<dt>comm<span class="classifier">mpi4py.MPI.Intracomm</span></dt><dd><p>MPI communicator (parallel processing)</p>
</dd>
<dt>M, K, C<span class="classifier">petsc4py.PETSc.Mat</span></dt><dd><p>FE matrices</p>
</dd>
<dt>F<span class="classifier">petsc4py.PETSc.Vec</span></dt><dd><p>FE force vector (internal excitation)</p>
</dd>
<dt>F_spectrum<span class="classifier">numpy.ndarray</span></dt><dd><p>the modulation spectrum of F (size must be the same as omega)</p>
</dd>
<dt>tbc<span class="classifier">list of pairs (name, dofs)</span></dt><dd><p>name is a string corresponding to the desired attribute name of a tbc (Waveguide object),
dofs is a numpy array of the degrees of freedom of the tbc (positive if outward
negative if inward)</p>
</dd>
<dt>omega<span class="classifier">numpy.ndarray</span></dt><dd><p>the angular frequency range, specified by the user in tbcs (Waveguide objects)</p>
</dd>
<dt>ksp: KSP object (PETSc object)</dt><dd><p>solver parameters</p>
</dd>
<dt>displacement<span class="classifier">list of PETSc vectors</span></dt><dd><p>for each angular frequency, the FE displacement vector U (solution of the scattering problem)</p>
</dd>
<dt>energy_balance<span class="classifier">list of 1d numpy array</span></dt><dd><p>for each angular frequency, energy_balance[i] gives the following three-component array,
[Pin-i*omega/2*U^H*F, Ptot, -i*omega*U^H*D*U], where P=-i*omega/2*U^H*T:
- the term Pin-i*omega/2*U^H*F represents the input power, supplied by ingoing modes and internal</p>
<blockquote>
<div><p>forces (this term should have a negative real part)</p>
</div></blockquote>
<ul class="simple">
<li><p>the term Ptot is the complex power flow of the sum of ingoing and ougoing modes</p></li>
<li><p>the term -i*omega*U^H*D*U is related to the kinetic, potential and dissipated energies in the volume
(the dissipated energy, defined as positive, is equal to the real part of this term divided by -2*omega).</p></li>
<li><p>a perfect energy balance is achived if Ptot = -i*omega*U^H*D*U</p></li>
</ul>
</dd>
<dt>name.coefficient<span class="classifier">list of numpy.ndarray, where name is a Waveguide object associated with a given transparent BC</span></dt><dd><p>this transparent BC attribute stores modal coefficients at each frequency:
- the coefficients of ingoing modes are considered as inputs, specified by the user (excitation in the scattering problem)
- the coefficients of outgoing modes are considered as initially unknown, solution of the scattering problem
Any non-zero outgoing amplitudes specified in name.coefficient prior to solving the scattering problem
will hence be discarded and replaced with the scattering solution.
If the attribute coefficient is empty prior to scattering (no specified ingoing modes), zero ingoing amplitudes
will be considered by default.</p>
</dd>
</dl>
</section>
<section id="id49">
<h2>Methods<a class="headerlink" href="#id49" title="Permalink to this heading"></a></h2>
<dl class="simple">
<dt>__init__(comm:’_MPI.Comm’, M:PETSc.Mat, K:PETSc.Mat, C:PETSc.Mat, tbcs:list):</dt><dd><p>Constructor, initialization of scattering problem</p>
</dd>
<dt>set_ingoing_mode(tbc_name, mode, spectrum=None):</dt><dd><p>For a given tbc, specified by the string tbc_name, set the coefficient of a single mode to 1.
mode is a list of indices identifying the mode position at each frequency.</p>
</dd>
<dt>set_internal_excitation(F, F_spectrum=None):</dt><dd><p>Set the internal excitation vector F and its spectrum F_spectrum</p>
</dd>
<dt>set_parameters(solver=’iterative’):</dt><dd><p>Set default parameters of KSP solver (stored in attribute ksp)</p>
</dd>
<dt>solve():</dt><dd><p>Solve the scattering problem repeatedly for the angular frequency range, solutions are stored as attributes
(names: displacement, energy_balance)</p>
</dd>
<dt>plot_energy_balance():</dt><dd><p>Plot the three terms of energy_balance (complex modulus) at each frequency index for checking modal tbc truncature</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.scattering.Scattering.set_ingoing_mode">
<span class="sig-name descname"><span class="pre">set_ingoing_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tbc_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/scattering.html#Scattering.set_ingoing_mode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.scattering.Scattering.set_ingoing_mode" title="Permalink to this definition"></a></dt>
<dd><p>For a given tbc, specified by the string tbc_name, set the coefficient of a single mode to 1. The coefficients of
all other modes are set to 0. mode is a list of indices identifying the mode position at each frequency
(see also method track_mode() of class Waveguide).
Please ensure that this mode is an ingoing mode (non-zero outgoing amplitudes will be discarded).
When specified, spectrum is a vector of length omega (numpy.array) used to modulate the coefficient in terms of
frequency (default: 1 for all frequencies).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.scattering.Scattering.set_internal_excitation">
<span class="sig-name descname"><span class="pre">set_internal_excitation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F_spectrum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/scattering.html#Scattering.set_internal_excitation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.scattering.Scattering.set_internal_excitation" title="Permalink to this definition"></a></dt>
<dd><p>Set the internal excitation vector F (petsc4py.PETSc.Vec).
When specified, F_spectrum is a vector of length omega (numpy.array) used to modulate F in terms of
frequency (default: 1 for all frequencies).
F and F_spectrum are stored as attributes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.scattering.Scattering.set_parameters">
<span class="sig-name descname"><span class="pre">set_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'iterative'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/scattering.html#Scattering.set_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.scattering.Scattering.set_parameters" title="Permalink to this definition"></a></dt>
<dd><p>Set default parameters of KSP solver (stored into the attribute ksp.)
The preselected methods are CGS (iterative method) and MUMPS (direct method).
CGS is used by default, set solver=’direct’ to use MUMPS instead.
After calling this method, various PETSc parameters can be set by changing the attribute ksp manually.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.scattering.Scattering.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/scattering.html#Scattering.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.scattering.Scattering.solve" title="Permalink to this definition"></a></dt>
<dd><p>Solve the scattering problem, i.e. the linear system repeatedly for the angular frequency range.
The solutions are stored in the attributes displacement and energy_balance.
The FE problem D*U=F is transformed into:
Bout^T*(D*Bout-Tout)*Uout = Bout^T*(Tin-D*Bin)*Uin
where:
- D is the dynamic stiffness matrix (D=K-omega**2*M-1j*omega*C)
- Bin and Bout (resp. Tin and Tout) are bases containing ingoing and outgoing modal</p>
<blockquote>
<div><p>displacements (resp. forces) so that: U=Bin*Uin+Bout*Uout, F=Tin*Uin+Tout*Uout</p>
</div></blockquote>
<ul class="simple">
<li><p>Uin contains internal forces and known ingoing amplitudes (zero by default, if not specified)</p></li>
<li><p>Uout is the solution containing outgoing modal amplitudes and internal dofs</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="waveguicsx.scattering.Scattering.plot_energy_balance">
<span class="sig-name descname"><span class="pre">plot_energy_balance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linewidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linestyle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/waveguicsx/scattering.html#Scattering.plot_energy_balance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#waveguicsx.scattering.Scattering.plot_energy_balance" title="Permalink to this definition"></a></dt>
<dd><p>Plot energy balance at each frequency index for checking modal tbc truncature.
The energy balance is defined as the difference between tbc net flux and volume power
divided by the input power (values close to zero indicate that enough modes have
been included in the transparent BCs).</p>
<section id="id50">
<h3>Parameters<a class="headerlink" href="#id50" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>ax: matplotlib axis</dt><dd><p>the matplotlib axis on which to plot data (created if None)</p>
</dd>
</dl>
<p>color: str, linewidth: int, linestyle: str, <a href="#id51"><span class="problematic" id="id52">**</span></a>kwargs are passed to ax.plot</p>
</section>
<section id="id53">
<h3>Returns<a class="headerlink" href="#id53" title="Permalink to this heading"></a></h3>
<p>ll: the matplotlib list of lines</p>
</section>
</dd></dl>

</section>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="documentation.html" class="btn btn-neutral float-left" title="Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tutorials.html" class="btn btn-neutral float-right" title="Tutorials" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2024, Fabien Treyssede.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>